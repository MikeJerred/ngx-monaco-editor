<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>ngx-monaco-editor-demo documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/material.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">ngx-monaco-editor-demo documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ILanguageExtensionPoint</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/ngx-monaco-editor/src/lib/interfaces/monaco.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#aliases">aliases</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#configuration">configuration</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#extensions">extensions</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#filenamePatterns">filenamePatterns</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#filenames">filenames</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#firstLine">firstLine</a>
                                </li>
                                <li>
                                        <a href="#id">id</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#mimetypes">mimetypes</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="aliases"></a>
                                        <span class="name"><b>aliases</b><a href="#aliases"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>aliases:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="configuration"></a>
                                        <span class="name"><b>configuration</b><a href="#configuration"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>configuration:         <code><a href="../classes/Uri.html" target="_self" >Uri</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../classes/Uri.html" target="_self" >Uri</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="extensions"></a>
                                        <span class="name"><b>extensions</b><a href="#extensions"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>extensions:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="filenamePatterns"></a>
                                        <span class="name"><b>filenamePatterns</b><a href="#filenamePatterns"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>filenamePatterns:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="filenames"></a>
                                        <span class="name"><b>filenames</b><a href="#filenames"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>filenames:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="firstLine"></a>
                                        <span class="name"><b>firstLine</b><a href="#firstLine"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>firstLine:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="id"></a>
                                        <span class="name"><b>id</b><a href="#id"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>id:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="mimetypes"></a>
                                        <span class="name"><b>mimetypes</b><a href="#mimetypes"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>mimetypes:     <code>string[]</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string[]</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">declare let MonacoEnvironment: monaco.Environment | undefined;

interface Window {
    MonacoEnvironment?: monaco.Environment | undefined;
}

declare namespace monaco {

    export type Thenable&lt;T&gt; &#x3D; PromiseLike&lt;T&gt;;

    export interface Environment {
        globalAPI?: boolean;
        baseUrl?: string;
        getWorker?(workerId: string, label: string): Worker;
        getWorkerUrl?(workerId: string, label: string): string;
    }

    export interface IDisposable {
        dispose(): void;
    }

    export interface IEvent&lt;T&gt; {
        (listener: (e: T) &#x3D;&gt; any, thisArg?: any): IDisposable;
    }

    /**
     * A helper that allows to emit and listen to typed events
     */
    export class Emitter&lt;T&gt; {
        constructor();
        readonly event: IEvent&lt;T&gt;;
        fire(event: T): void;
        dispose(): void;
    }


    export enum MarkerTag {
        Unnecessary &#x3D; 1,
        Deprecated &#x3D; 2
    }

    export enum MarkerSeverity {
        Hint &#x3D; 1,
        Info &#x3D; 2,
        Warning &#x3D; 4,
        Error &#x3D; 8
    }

    export class CancellationTokenSource {
        constructor(parent?: CancellationToken);
        get token(): CancellationToken;
        cancel(): void;
        dispose(cancel?: boolean): void;
    }

    export interface CancellationToken {
        /**
         * A flag signalling is cancellation has been requested.
         */
        readonly isCancellationRequested: boolean;
        /**
         * An event which fires when cancellation is requested. This event
         * only ever fires &#x60;once&#x60; as cancellation can only happen once. Listeners
         * that are registered after cancellation will be called (next event loop run),
         * but also only once.
         *
         * @event
         */
        readonly onCancellationRequested: (listener: (e: any) &#x3D;&gt; any, thisArgs?: any, disposables?: IDisposable[]) &#x3D;&gt; IDisposable;
    }
    /**
     * Uniform Resource Identifier (Uri) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component parts
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     * &#x60;&#x60;&#x60;txt
     *       foo://example.com:8042/over/there?name&#x3D;ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     * &#x60;&#x60;&#x60;
     */
    export class Uri implements UriComponents {
        static isUri(thing: any): thing is Uri;
        /**
         * scheme is the &#x27;http&#x27; part of &#x27;http://www.msft.com/some/path?query#fragment&#x27;.
         * The part before the first colon.
         */
        readonly scheme: string;
        /**
         * authority is the &#x27;www.msft.com&#x27; part of &#x27;http://www.msft.com/some/path?query#fragment&#x27;.
         * The part between the first double slashes and the next slash.
         */
        readonly authority: string;
        /**
         * path is the &#x27;/some/path&#x27; part of &#x27;http://www.msft.com/some/path?query#fragment&#x27;.
         */
        readonly path: string;
        /**
         * query is the &#x27;query&#x27; part of &#x27;http://www.msft.com/some/path?query#fragment&#x27;.
         */
        readonly query: string;
        /**
         * fragment is the &#x27;fragment&#x27; part of &#x27;http://www.msft.com/some/path?query#fragment&#x27;.
         */
        readonly fragment: string;
        /**
         * Returns a string representing the corresponding file system path of this Uri.
         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
         * platform specific path separator.
         *
         * * Will *not* validate the path for invalid characters and semantics.
         * * Will *not* look at the scheme of this Uri.
         * * The result shall *not* be used for display purposes but for accessing a file on disk.
         *
         *
         * The *difference* to &#x60;Uri#path&#x60; is the use of the platform specific separator and the handling
         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
         *
         * &#x60;&#x60;&#x60;ts
            const u &#x3D; Uri.parse(&#x27;file://server/c$/folder/file.txt&#x27;)
            u.authority &#x3D;&#x3D;&#x3D; &#x27;server&#x27;
            u.path &#x3D;&#x3D;&#x3D; &#x27;/shares/c$/file.txt&#x27;
            u.fsPath &#x3D;&#x3D;&#x3D; &#x27;\\server\c$\folder\file.txt&#x27;
        &#x60;&#x60;&#x60;
         *
         * Using &#x60;Uri#path&#x60; to read a file (using fs-apis) would not be enough because parts of the path,
         * namely the server name, would be missing. Therefore &#x60;Uri#fsPath&#x60; exists - it&#x27;s sugar to ease working
         * with URIs that represent files on disk (&#x60;file&#x60; scheme).
         */
        get fsPath(): string;
        with(change: {
            scheme?: string;
            authority?: string | null;
            path?: string | null;
            query?: string | null;
            fragment?: string | null;
        }): Uri;
        /**
         * Creates a new Uri from a string, e.g. &#x60;http://www.msft.com/some/path&#x60;,
         * &#x60;file:///usr/home&#x60;, or &#x60;scheme:with/path&#x60;.
         *
         * @param value A string which represents an Uri (see &#x60;Uri#toString&#x60;).
         */
        static parse(value: string, _strict?: boolean): Uri;
        /**
         * Creates a new Uri from a file system path, e.g. &#x60;c:\my\files&#x60;,
         * &#x60;/usr/home&#x60;, or &#x60;\\server\share\some\path&#x60;.
         *
         * The *difference* between &#x60;Uri#parse&#x60; and &#x60;Uri#file&#x60; is that the latter treats the argument
         * as path, not as stringified-uri. E.g. &#x60;Uri.file(path)&#x60; is **not the same as**
         * &#x60;Uri.parse(&#x27;file://&#x27; + path)&#x60; because the path might contain characters that are
         * interpreted (# and ?). See the following sample:
         * &#x60;&#x60;&#x60;ts
        const good &#x3D; Uri.file(&#x27;/coding/c#/project1&#x27;);
        good.scheme &#x3D;&#x3D;&#x3D; &#x27;file&#x27;;
        good.path &#x3D;&#x3D;&#x3D; &#x27;/coding/c#/project1&#x27;;
        good.fragment &#x3D;&#x3D;&#x3D; &#x27;&#x27;;
        const bad &#x3D; Uri.parse(&#x27;file://&#x27; + &#x27;/coding/c#/project1&#x27;);
        bad.scheme &#x3D;&#x3D;&#x3D; &#x27;file&#x27;;
        bad.path &#x3D;&#x3D;&#x3D; &#x27;/coding/c&#x27;; // path is now broken
        bad.fragment &#x3D;&#x3D;&#x3D; &#x27;/project1&#x27;;
        &#x60;&#x60;&#x60;
         *
         * @param path A file system path (see &#x60;Uri#fsPath&#x60;)
         */
        static file(path: string): Uri;
        static from(components: {
            scheme: string;
            authority?: string;
            path?: string;
            query?: string;
            fragment?: string;
        }): Uri;
        /**
         * Join a Uri path with path fragments and normalizes the resulting path.
         *
         * @param uri The input Uri.
         * @param pathFragment The path fragment to add to the Uri path.
         * @returns The resulting Uri.
         */
        static joinPath(uri: Uri, ...pathFragment: string[]): Uri;
        /**
         * Creates a string representation for this Uri. It&#x27;s guaranteed that calling
         * &#x60;Uri.parse&#x60; with the result of this function creates an Uri which is equal
         * to this Uri.
         *
         * * The result shall *not* be used for display purposes but for externalization or transport.
         * * The result will be encoded using the percentage encoding and encoding happens mostly
         * ignore the scheme-specific encoding rules.
         *
         * @param skipEncoding Do not encode the result, default is &#x60;false&#x60;
         */
        toString(skipEncoding?: boolean): string;
        toJSON(): UriComponents;
        static revive(data: UriComponents | Uri): Uri;
        static revive(data: UriComponents | Uri | undefined): Uri | undefined;
        static revive(data: UriComponents | Uri | null): Uri | null;
        static revive(data: UriComponents | Uri | undefined | null): Uri | undefined | null;
    }

    export interface UriComponents {
        scheme: string;
        authority: string;
        path: string;
        query: string;
        fragment: string;
    }
    /**
     * Virtual Key Codes, the value does not hold any inherent meaning.
     * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v&#x3D;vs.85).aspx
     * But these are &quot;more general&quot;, as they should work across browsers &amp; OS&#x60;s.
     */
    export enum KeyCode {
        DependsOnKbLayout &#x3D; -1,
        /**
         * Placed first to cover the 0 value of the enum.
         */
        Unknown &#x3D; 0,
        Backspace &#x3D; 1,
        Tab &#x3D; 2,
        Enter &#x3D; 3,
        Shift &#x3D; 4,
        Ctrl &#x3D; 5,
        Alt &#x3D; 6,
        PauseBreak &#x3D; 7,
        CapsLock &#x3D; 8,
        Escape &#x3D; 9,
        Space &#x3D; 10,
        PageUp &#x3D; 11,
        PageDown &#x3D; 12,
        End &#x3D; 13,
        Home &#x3D; 14,
        LeftArrow &#x3D; 15,
        UpArrow &#x3D; 16,
        RightArrow &#x3D; 17,
        DownArrow &#x3D; 18,
        Insert &#x3D; 19,
        Delete &#x3D; 20,
        Digit0 &#x3D; 21,
        Digit1 &#x3D; 22,
        Digit2 &#x3D; 23,
        Digit3 &#x3D; 24,
        Digit4 &#x3D; 25,
        Digit5 &#x3D; 26,
        Digit6 &#x3D; 27,
        Digit7 &#x3D; 28,
        Digit8 &#x3D; 29,
        Digit9 &#x3D; 30,
        KeyA &#x3D; 31,
        KeyB &#x3D; 32,
        KeyC &#x3D; 33,
        KeyD &#x3D; 34,
        KeyE &#x3D; 35,
        KeyF &#x3D; 36,
        KeyG &#x3D; 37,
        KeyH &#x3D; 38,
        KeyI &#x3D; 39,
        KeyJ &#x3D; 40,
        KeyK &#x3D; 41,
        KeyL &#x3D; 42,
        KeyM &#x3D; 43,
        KeyN &#x3D; 44,
        KeyO &#x3D; 45,
        KeyP &#x3D; 46,
        KeyQ &#x3D; 47,
        KeyR &#x3D; 48,
        KeyS &#x3D; 49,
        KeyT &#x3D; 50,
        KeyU &#x3D; 51,
        KeyV &#x3D; 52,
        KeyW &#x3D; 53,
        KeyX &#x3D; 54,
        KeyY &#x3D; 55,
        KeyZ &#x3D; 56,
        Meta &#x3D; 57,
        ContextMenu &#x3D; 58,
        F1 &#x3D; 59,
        F2 &#x3D; 60,
        F3 &#x3D; 61,
        F4 &#x3D; 62,
        F5 &#x3D; 63,
        F6 &#x3D; 64,
        F7 &#x3D; 65,
        F8 &#x3D; 66,
        F9 &#x3D; 67,
        F10 &#x3D; 68,
        F11 &#x3D; 69,
        F12 &#x3D; 70,
        F13 &#x3D; 71,
        F14 &#x3D; 72,
        F15 &#x3D; 73,
        F16 &#x3D; 74,
        F17 &#x3D; 75,
        F18 &#x3D; 76,
        F19 &#x3D; 77,
        NumLock &#x3D; 78,
        ScrollLock &#x3D; 79,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;;:&#x27; key
         */
        Semicolon &#x3D; 80,
        /**
         * For any country/region, the &#x27;+&#x27; key
         * For the US standard keyboard, the &#x27;&#x3D;+&#x27; key
         */
        Equal &#x3D; 81,
        /**
         * For any country/region, the &#x27;,&#x27; key
         * For the US standard keyboard, the &#x27;,&lt;&#x27; key
         */
        Comma &#x3D; 82,
        /**
         * For any country/region, the &#x27;-&#x27; key
         * For the US standard keyboard, the &#x27;-_&#x27; key
         */
        Minus &#x3D; 83,
        /**
         * For any country/region, the &#x27;.&#x27; key
         * For the US standard keyboard, the &#x27;.&gt;&#x27; key
         */
        Period &#x3D; 84,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;/?&#x27; key
         */
        Slash &#x3D; 85,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;&#x60;~&#x27; key
         */
        Backquote &#x3D; 86,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;[{&#x27; key
         */
        BracketLeft &#x3D; 87,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;\|&#x27; key
         */
        Backslash &#x3D; 88,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;]}&#x27; key
         */
        BracketRight &#x3D; 89,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the &#x27;&#x27;&quot;&#x27; key
         */
        Quote &#x3D; 90,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        OEM_8 &#x3D; 91,
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        IntlBackslash &#x3D; 92,
        Numpad0 &#x3D; 93,
        Numpad1 &#x3D; 94,
        Numpad2 &#x3D; 95,
        Numpad3 &#x3D; 96,
        Numpad4 &#x3D; 97,
        Numpad5 &#x3D; 98,
        Numpad6 &#x3D; 99,
        Numpad7 &#x3D; 100,
        Numpad8 &#x3D; 101,
        Numpad9 &#x3D; 102,
        NumpadMultiply &#x3D; 103,
        NumpadAdd &#x3D; 104,
        NUMPAD_SEPARATOR &#x3D; 105,
        NumpadSubtract &#x3D; 106,
        NumpadDecimal &#x3D; 107,
        NumpadDivide &#x3D; 108,
        /**
         * Cover all key codes when IME is processing input.
         */
        KEY_IN_COMPOSITION &#x3D; 109,
        ABNT_C1 &#x3D; 110,
        ABNT_C2 &#x3D; 111,
        AudioVolumeMute &#x3D; 112,
        AudioVolumeUp &#x3D; 113,
        AudioVolumeDown &#x3D; 114,
        BrowserSearch &#x3D; 115,
        BrowserHome &#x3D; 116,
        BrowserBack &#x3D; 117,
        BrowserForward &#x3D; 118,
        MediaTrackNext &#x3D; 119,
        MediaTrackPrevious &#x3D; 120,
        MediaStop &#x3D; 121,
        MediaPlayPause &#x3D; 122,
        LaunchMediaPlayer &#x3D; 123,
        LaunchMail &#x3D; 124,
        LaunchApp2 &#x3D; 125,
        /**
         * Placed last to cover the length of the enum.
         * Please do not depend on this value!
         */
        MAX_VALUE &#x3D; 126
    }
    export class KeyMod {
        static readonly CtrlCmd: number;
        static readonly Shift: number;
        static readonly Alt: number;
        static readonly WinCtrl: number;
        static chord(firstPart: number, secondPart: number): number;
    }

    export interface IMarkdownString {
        readonly value: string;
        readonly isTrusted?: boolean;
        readonly supportThemeIcons?: boolean;
        readonly supportHtml?: boolean;
        uris?: {
            [href: string]: UriComponents;
        };
    }

    export interface IKeyboardEvent {
        readonly _standardKeyboardEventBrand: true;
        readonly browserEvent: KeyboardEvent;
        readonly target: HTMLElement;
        readonly ctrlKey: boolean;
        readonly shiftKey: boolean;
        readonly altKey: boolean;
        readonly metaKey: boolean;
        readonly keyCode: KeyCode;
        readonly code: string;
        equals(keybinding: number): boolean;
        preventDefault(): void;
        stopPropagation(): void;
    }
    export interface IMouseEvent {
        readonly browserEvent: MouseEvent;
        readonly leftButton: boolean;
        readonly middleButton: boolean;
        readonly rightButton: boolean;
        readonly buttons: number;
        readonly target: HTMLElement;
        readonly detail: number;
        readonly posx: number;
        readonly posy: number;
        readonly ctrlKey: boolean;
        readonly shiftKey: boolean;
        readonly altKey: boolean;
        readonly metaKey: boolean;
        readonly timestamp: number;
        preventDefault(): void;
        stopPropagation(): void;
    }

    export interface IScrollEvent {
        readonly scrollTop: number;
        readonly scrollLeft: number;
        readonly scrollWidth: number;
        readonly scrollHeight: number;
        readonly scrollTopChanged: boolean;
        readonly scrollLeftChanged: boolean;
        readonly scrollWidthChanged: boolean;
        readonly scrollHeightChanged: boolean;
    }
    /**
     * A position in the editor. This interface is suitable for serialization.
     */
    export interface IPosition {
        /**
         * line number (starts at 1)
         */
        readonly lineNumber: number;
        /**
         * column (the first character in a line is between column 1 and column 2)
         */
        readonly column: number;
    }

    /**
     * A position in the editor.
     */
    export class Position {
        /**
         * line number (starts at 1)
         */
        readonly lineNumber: number;
        /**
         * column (the first character in a line is between column 1 and column 2)
         */
        readonly column: number;
        constructor(lineNumber: number, column: number);
        /**
         * Create a new position from this position.
         *
         * @param newLineNumber new line number
         * @param newColumn new column
         */
        with(newLineNumber?: number, newColumn?: number): Position;
        /**
         * Derive a new position from this position.
         *
         * @param deltaLineNumber line number delta
         * @param deltaColumn column delta
         */
        delta(deltaLineNumber?: number, deltaColumn?: number): Position;
        /**
         * Test if this position equals other position
         */
        equals(other: IPosition): boolean;
        /**
         * Test if position &#x60;a&#x60; equals position &#x60;b&#x60;
         */
        static equals(a: IPosition | null, b: IPosition | null): boolean;
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be false.
         */
        isBefore(other: IPosition): boolean;
        /**
         * Test if position &#x60;a&#x60; is before position &#x60;b&#x60;.
         * If the two positions are equal, the result will be false.
         */
        static isBefore(a: IPosition, b: IPosition): boolean;
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be true.
         */
        isBeforeOrEqual(other: IPosition): boolean;
        /**
         * Test if position &#x60;a&#x60; is before position &#x60;b&#x60;.
         * If the two positions are equal, the result will be true.
         */
        static isBeforeOrEqual(a: IPosition, b: IPosition): boolean;
        /**
         * A function that compares positions, useful for sorting
         */
        static compare(a: IPosition, b: IPosition): number;
        /**
         * Clone this position.
         */
        clone(): Position;
        /**
         * Convert to a human-readable representation.
         */
        toString(): string;
        /**
         * Create a &#x60;Position&#x60; from an &#x60;IPosition&#x60;.
         */
        static lift(pos: IPosition): Position;
        /**
         * Test if &#x60;obj&#x60; is an &#x60;IPosition&#x60;.
         */
        static isIPosition(obj: any): obj is IPosition;
    }

    /**
     * A range in the editor. This interface is suitable for serialization.
     */
    export interface IRange {
        /**
         * Line number on which the range starts (starts at 1).
         */
        readonly startLineNumber: number;
        /**
         * Column on which the range starts in line &#x60;startLineNumber&#x60; (starts at 1).
         */
        readonly startColumn: number;
        /**
         * Line number on which the range ends.
         */
        readonly endLineNumber: number;
        /**
         * Column on which the range ends in line &#x60;endLineNumber&#x60;.
         */
        readonly endColumn: number;
    }

    /**
     * A range in the editor. (startLineNumber,startColumn) is &lt;&#x3D; (endLineNumber,endColumn)
     */
    export class Range {
        /**
         * Line number on which the range starts (starts at 1).
         */
        readonly startLineNumber: number;
        /**
         * Column on which the range starts in line &#x60;startLineNumber&#x60; (starts at 1).
         */
        readonly startColumn: number;
        /**
         * Line number on which the range ends.
         */
        readonly endLineNumber: number;
        /**
         * Column on which the range ends in line &#x60;endLineNumber&#x60;.
         */
        readonly endColumn: number;
        constructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number);
        /**
         * Test if this range is empty.
         */
        isEmpty(): boolean;
        /**
         * Test if &#x60;range&#x60; is empty.
         */
        static isEmpty(range: IRange): boolean;
        /**
         * Test if position is in this range. If the position is at the edges, will return true.
         */
        containsPosition(position: IPosition): boolean;
        /**
         * Test if &#x60;position&#x60; is in &#x60;range&#x60;. If the position is at the edges, will return true.
         */
        static containsPosition(range: IRange, position: IPosition): boolean;
        /**
         * Test if range is in this range. If the range is equal to this range, will return true.
         */
        containsRange(range: IRange): boolean;
        /**
         * Test if &#x60;otherRange&#x60; is in &#x60;range&#x60;. If the ranges are equal, will return true.
         */
        static containsRange(range: IRange, otherRange: IRange): boolean;
        /**
         * Test if &#x60;range&#x60; is strictly in this range. &#x60;range&#x60; must start after and end before this range for the result to be true.
         */
        strictContainsRange(range: IRange): boolean;
        /**
         * Test if &#x60;otherRange&#x60; is strictly in &#x60;range&#x60; (must start after, and end before). If the ranges are equal, will return false.
         */
        static strictContainsRange(range: IRange, otherRange: IRange): boolean;
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        plusRange(range: IRange): Range;
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        static plusRange(a: IRange, b: IRange): Range;
        /**
         * A intersection of the two ranges.
         */
        intersectRanges(range: IRange): Range | null;
        /**
         * A intersection of the two ranges.
         */
        static intersectRanges(a: IRange, b: IRange): Range | null;
        /**
         * Test if this range equals other.
         */
        equalsRange(other: IRange | null): boolean;
        /**
         * Test if range &#x60;a&#x60; equals &#x60;b&#x60;.
         */
        static equalsRange(a: IRange | null, b: IRange | null): boolean;
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        getEndPosition(): Position;
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        static getEndPosition(range: IRange): Position;
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        getStartPosition(): Position;
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        static getStartPosition(range: IRange): Position;
        /**
         * Transform to a user presentable string representation.
         */
        toString(): string;
        /**
         * Create a new range using this range&#x27;s start position, and using endLineNumber and endColumn as the end position.
         */
        setEndPosition(endLineNumber: number, endColumn: number): Range;
        /**
         * Create a new range using this range&#x27;s end position, and using startLineNumber and startColumn as the start position.
         */
        setStartPosition(startLineNumber: number, startColumn: number): Range;
        /**
         * Create a new empty range using this range&#x27;s start position.
         */
        collapseToStart(): Range;
        /**
         * Create a new empty range using this range&#x27;s start position.
         */
        static collapseToStart(range: IRange): Range;
        static fromPositions(start: IPosition, end?: IPosition): Range;
        /**
         * Create a &#x60;Range&#x60; from an &#x60;IRange&#x60;.
         */
        static lift(range: undefined | null): null;
        static lift(range: IRange): Range;
        /**
         * Test if &#x60;obj&#x60; is an &#x60;IRange&#x60;.
         */
        static isIRange(obj: any): obj is IRange;
        /**
         * Test if the two ranges are touching in any way.
         */
        static areIntersectingOrTouching(a: IRange, b: IRange): boolean;
        /**
         * Test if the two ranges are intersecting. If the ranges are touching it returns true.
         */
        static areIntersecting(a: IRange, b: IRange): boolean;
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number;
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        static compareRangesUsingEnds(a: IRange, b: IRange): number;
        /**
         * Test if the range spans multiple lines.
         */
        static spansMultipleLines(range: IRange): boolean;
    }

    /**
     * A selection in the editor.
     * The selection is a range that has an orientation.
     */
    export interface ISelection {
        /**
         * The line number on which the selection has started.
         */
        readonly selectionStartLineNumber: number;
        /**
         * The column on &#x60;selectionStartLineNumber&#x60; where the selection has started.
         */
        readonly selectionStartColumn: number;
        /**
         * The line number on which the selection has ended.
         */
        readonly positionLineNumber: number;
        /**
         * The column on &#x60;positionLineNumber&#x60; where the selection has ended.
         */
        readonly positionColumn: number;
    }

    /**
     * A selection in the editor.
     * The selection is a range that has an orientation.
     */
    export class Selection extends Range {
        /**
         * The line number on which the selection has started.
         */
        readonly selectionStartLineNumber: number;
        /**
         * The column on &#x60;selectionStartLineNumber&#x60; where the selection has started.
         */
        readonly selectionStartColumn: number;
        /**
         * The line number on which the selection has ended.
         */
        readonly positionLineNumber: number;
        /**
         * The column on &#x60;positionLineNumber&#x60; where the selection has ended.
         */
        readonly positionColumn: number;
        constructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number);
        /**
         * Transform to a human-readable representation.
         */
        toString(): string;
        /**
         * Test if equals other selection.
         */
        equalsSelection(other: ISelection): boolean;
        /**
         * Test if the two selections are equal.
         */
        static selectionsEqual(a: ISelection, b: ISelection): boolean;
        /**
         * Get directions (LTR or RTL).
         */
        getDirection(): SelectionDirection;
        /**
         * Create a new selection with a different &#x60;positionLineNumber&#x60; and &#x60;positionColumn&#x60;.
         */
        setEndPosition(endLineNumber: number, endColumn: number): Selection;
        /**
         * Get the position at &#x60;positionLineNumber&#x60; and &#x60;positionColumn&#x60;.
         */
        getPosition(): Position;
        /**
         * Get the position at the start of the selection.
        */
        getSelectionStart(): Position;
        /**
         * Create a new selection with a different &#x60;selectionStartLineNumber&#x60; and &#x60;selectionStartColumn&#x60;.
         */
        setStartPosition(startLineNumber: number, startColumn: number): Selection;
        /**
         * Create a &#x60;Selection&#x60; from one or two positions
         */
        static fromPositions(start: IPosition, end?: IPosition): Selection;
        /**
         * Creates a &#x60;Selection&#x60; from a range, given a direction.
         */
        static fromRange(range: Range, direction: SelectionDirection): Selection;
        /**
         * Create a &#x60;Selection&#x60; from an &#x60;ISelection&#x60;.
         */
        static liftSelection(sel: ISelection): Selection;
        /**
         * &#x60;a&#x60; equals &#x60;b&#x60;.
         */
        static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean;
        /**
         * Test if &#x60;obj&#x60; is an &#x60;ISelection&#x60;.
         */
        static isISelection(obj: any): obj is ISelection;
        /**
         * Create with a direction.
         */
        static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection;
    }

    /**
     * The direction of a selection.
     */
    export enum SelectionDirection {
        /**
         * The selection starts above where it ends.
         */
        LTR &#x3D; 0,
        /**
         * The selection starts below where it ends.
         */
        RTL &#x3D; 1
    }

    export class Token {
        _tokenBrand: void;
        readonly offset: number;
        readonly type: string;
        readonly language: string;
        constructor(offset: number, type: string, language: string);
        toString(): string;
    }
}

declare namespace monaco.editor {

    export interface IDiffNavigator {
        canNavigate(): boolean;
        next(): void;
        previous(): void;
        dispose(): void;
    }

    /**
     * Create a new editor under &#x60;domElement&#x60;.
     * &#x60;domElement&#x60; should be empty (not contain other dom nodes).
     * The editor will read the size of &#x60;domElement&#x60;.
     */
    export function create(domElement: HTMLElement, options?: IStandaloneEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneCodeEditor;

    /**
     * Emitted when an editor is created.
     * Creating a diff editor might cause this listener to be invoked with the two editors.
     * @event
     */
    export function onDidCreateEditor(listener: (codeEditor: ICodeEditor) &#x3D;&gt; void): IDisposable;

    /**
     * Create a new diff editor under &#x60;domElement&#x60;.
     * &#x60;domElement&#x60; should be empty (not contain other dom nodes).
     * The editor will read the size of &#x60;domElement&#x60;.
     */
    export function createDiffEditor(domElement: HTMLElement, options?: IStandaloneDiffEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneDiffEditor;

    export interface IDiffNavigatorOptions {
        readonly followsCaret?: boolean;
        readonly ignoreCharChanges?: boolean;
        readonly alwaysRevealFirst?: boolean;
    }

    export function createDiffNavigator(diffEditor: IStandaloneDiffEditor, opts?: IDiffNavigatorOptions): IDiffNavigator;

    /**
     * Create a new editor model.
     * You can specify the language that should be set for this model or let the language be inferred from the &#x60;uri&#x60;.
     */
    export function createModel(value: string, language?: string, uri?: Uri): ITextModel;

    /**
     * Change the language for a model.
     */
    export function setModelLanguage(model: ITextModel, languageId: string): void;

    /**
     * Set the markers for a model.
     */
    export function setModelMarkers(model: ITextModel, owner: string, markers: IMarkerData[]): void;

    /**
     * Get markers for owner and/or resource
     *
     * @returns list of markers
     */
    export function getModelMarkers(filter: {
        owner?: string;
        resource?: Uri;
        take?: number;
    }): IMarker[];

    /**
     * Emitted when markers change for a model.
     * @event
     */
    export function onDidChangeMarkers(listener: (e: readonly Uri[]) &#x3D;&gt; void): IDisposable;

    /**
     * Get the model that has &#x60;uri&#x60; if it exists.
     */
    export function getModel(uri: Uri): ITextModel | null;

    /**
     * Get all the created models.
     */
    export function getModels(): ITextModel[];

    /**
     * Emitted when a model is created.
     * @event
     */
    export function onDidCreateModel(listener: (model: ITextModel) &#x3D;&gt; void): IDisposable;

    /**
     * Emitted right before a model is disposed.
     * @event
     */
    export function onWillDisposeModel(listener: (model: ITextModel) &#x3D;&gt; void): IDisposable;

    /**
     * Emitted when a different language is set to a model.
     * @event
     */
    export function onDidChangeModelLanguage(listener: (e: {
        readonly model: ITextModel;
        readonly oldLanguage: string;
    }) &#x3D;&gt; void): IDisposable;

    /**
     * Create a new web worker that has model syncing capabilities built in.
     * Specify an AMD module to load that will &#x60;create&#x60; an object that will be proxied.
     */
    export function createWebWorker&lt;T&gt;(opts: IWebWorkerOptions): MonacoWebWorker&lt;T&gt;;

    /**
     * Colorize the contents of &#x60;domNode&#x60; using attribute &#x60;data-lang&#x60;.
     */
    export function colorizeElement(domNode: HTMLElement, options: IColorizerElementOptions): Promise&lt;void&gt;;

    /**
     * Colorize &#x60;text&#x60; using language &#x60;languageId&#x60;.
     */
    export function colorize(text: string, languageId: string, options: IColorizerOptions): Promise&lt;string&gt;;

    /**
     * Colorize a line in a model.
     */
    export function colorizeModelLine(model: ITextModel, lineNumber: number, tabSize?: number): string;

    /**
     * Tokenize &#x60;text&#x60; using language &#x60;languageId&#x60;
     */
    export function tokenize(text: string, languageId: string): Token[][];

    /**
     * Define a new theme or update an existing theme.
     */
    export function defineTheme(themeName: string, themeData: IStandaloneThemeData): void;

    /**
     * Switches to a theme.
     */
    export function setTheme(themeName: string): void;

    /**
     * Clears all cached font measurements and triggers re-measurement.
     */
    export function remeasureFonts(): void;

    /**
     * Register a command.
     */
    export function registerCommand(id: string, handler: (accessor: any, ...args: any[]) &#x3D;&gt; void): IDisposable;

    export type BuiltinTheme &#x3D; &#x27;vs&#x27; | &#x27;vs-dark&#x27; | &#x27;hc-black&#x27;;

    export interface IStandaloneThemeData {
        base: BuiltinTheme;
        inherit: boolean;
        rules: ITokenThemeRule[];
        encodedTokensColors?: string[];
        colors: IColors;
    }

    export type IColors &#x3D; {
        [colorId: string]: string;
    };

    export interface ITokenThemeRule {
        token: string;
        foreground?: string;
        background?: string;
        fontStyle?: string;
    }

    /**
     * A web worker that can provide a proxy to an arbitrary file.
     */
    export interface MonacoWebWorker&lt;T&gt; {
        /**
         * Terminate the web worker, thus invalidating the returned proxy.
         */
        dispose(): void;
        /**
         * Get a proxy to the arbitrary loaded code.
         */
        getProxy(): Promise&lt;T&gt;;
        /**
         * Synchronize (send) the models at &#x60;resources&#x60; to the web worker,
         * making them available in the monaco.worker.getMirrorModels().
         */
        withSyncedResources(resources: Uri[]): Promise&lt;T&gt;;
    }

    export interface IWebWorkerOptions {
        /**
         * The AMD moduleId to load.
         * It should export a function &#x60;create&#x60; that should return the exported proxy.
         */
        moduleId: string;
        /**
         * The data to send over when calling create on the module.
         */
        createData?: any;
        /**
         * A label to be used to identify the web worker for debugging purposes.
         */
        label?: string;
        /**
         * An object that can be used by the web worker to make calls back to the main thread.
         */
        host?: any;
        /**
         * Keep idle models.
         * Defaults to false, which means that idle models will stop syncing after a while.
         */
        keepIdleModels?: boolean;
    }

    /**
     * Description of an action contribution
     */
    export interface IActionDescriptor {
        /**
         * An unique identifier of the contributed action.
         */
        id: string;
        /**
         * A label of the action that will be presented to the user.
         */
        label: string;
        /**
         * Precondition rule.
         */
        precondition?: string;
        /**
         * An array of keybindings for the action.
         */
        keybindings?: number[];
        /**
         * The keybinding rule (condition on top of precondition).
         */
        keybindingContext?: string;
        /**
         * Control if the action should show up in the context menu and where.
         * The context menu of the editor has these default:
         *   navigation - The navigation group comes first in all cases.
         *   1_modification - This group comes next and contains commands that modify your code.
         *   9_cutcopypaste - The last default group with the basic editing commands.
         * You can also create your own group.
         * Defaults to null (don&#x27;t show in context menu).
         */
        contextMenuGroupId?: string;
        /**
         * Control the order in the context menu group.
         */
        contextMenuOrder?: number;
        /**
         * Method that will be executed when the action is triggered.
         * @param editor The editor instance is passed in as a convenience
         */
        run(editor: ICodeEditor, ...args: any[]): void | Promise&lt;void&gt;;
    }

    /**
     * Options which apply for all editors.
     */
    export interface IGlobalEditorOptions {
        /**
         * The number of spaces a tab is equal to.
         * This setting is overridden based on the file contents when &#x60;detectIndentation&#x60; is on.
         * Defaults to 4.
         */
        tabSize?: number;
        /**
         * Insert spaces when pressing &#x60;Tab&#x60;.
         * This setting is overridden based on the file contents when &#x60;detectIndentation&#x60; is on.
         * Defaults to true.
         */
        insertSpaces?: boolean;
        /**
         * Controls whether &#x60;tabSize&#x60; and &#x60;insertSpaces&#x60; will be automatically detected when a file is opened based on the file contents.
         * Defaults to true.
         */
        detectIndentation?: boolean;
        /**
         * Remove trailing auto inserted whitespace.
         * Defaults to true.
         */
        trimAutoWhitespace?: boolean;
        /**
         * Special handling for large files to disable certain memory intensive features.
         * Defaults to true.
         */
        largeFileOptimizations?: boolean;
        /**
         * Controls whether completions should be computed based on words in the document.
         * Defaults to true.
         */
        wordBasedSuggestions?: boolean;
        /**
         * Controls whether word based completions should be included from opened documents of the same language or any language.
         */
        wordBasedSuggestionsOnlySameLanguage?: boolean;
        /**
         * Controls whether the semanticHighlighting is shown for the languages that support it.
         * true: semanticHighlighting is enabled for all themes
         * false: semanticHighlighting is disabled for all themes
         * &#x27;configuredByTheme&#x27;: semanticHighlighting is controlled by the current color theme&#x27;s semanticHighlighting setting.
         * Defaults to &#x27;byTheme&#x27;.
         */
        &#x27;semanticHighlighting.enabled&#x27;?: true | false | &#x27;configuredByTheme&#x27;;
        /**
         * Keep peek editors open even when double clicking their content or when hitting &#x60;Escape&#x60;.
         * Defaults to false.
         */
        stablePeek?: boolean;
        /**
         * Lines above this length will not be tokenized for performance reasons.
         * Defaults to 20000.
         */
        maxTokenizationLineLength?: number;
        /**
         * Theme to be used for rendering.
         * The current out-of-the-box available themes are: &#x27;vs&#x27; (default), &#x27;vs-dark&#x27;, &#x27;hc-black&#x27;.
         * You can create custom themes via &#x60;monaco.editor.defineTheme&#x60;.
         * To switch a theme, use &#x60;monaco.editor.setTheme&#x60;.
         * **NOTE**: The theme might be overwritten if the OS is in high contrast mode, unless &#x60;autoDetectHighContrast&#x60; is set to false.
         */
        theme?: string;
        /**
         * If enabled, will automatically change to high contrast theme if the OS is using a high contrast theme.
         * Defaults to true.
         */
        autoDetectHighContrast?: boolean;
    }

    /**
     * The options to create an editor.
     */
    export interface IStandaloneEditorConstructionOptions extends IEditorConstructionOptions, IGlobalEditorOptions {
        /**
         * The initial model associated with this code editor.
         */
        model?: ITextModel | null;
        /**
         * The initial value of the auto created model in the editor.
         * To not automatically create a model, use &#x60;model: null&#x60;.
         */
        value?: string;
        /**
         * The initial language of the auto created model in the editor.
         * To not automatically create a model, use &#x60;model: null&#x60;.
         */
        language?: string;
        /**
         * Initial theme to be used for rendering.
         * The current out-of-the-box available themes are: &#x27;vs&#x27; (default), &#x27;vs-dark&#x27;, &#x27;hc-black&#x27;.
         * You can create custom themes via &#x60;monaco.editor.defineTheme&#x60;.
         * To switch a theme, use &#x60;monaco.editor.setTheme&#x60;.
         * **NOTE**: The theme might be overwritten if the OS is in high contrast mode, unless &#x60;autoDetectHighContrast&#x60; is set to false.
         */
        theme?: string;
        /**
         * If enabled, will automatically change to high contrast theme if the OS is using a high contrast theme.
         * Defaults to true.
         */
        autoDetectHighContrast?: boolean;
        /**
         * An URL to open when Ctrl+H (Windows and Linux) or Cmd+H (OSX) is pressed in
         * the accessibility help dialog in the editor.
         *
         * Defaults to &quot;https://go.microsoft.com/fwlink/?linkid&#x3D;852450&quot;
         */
        accessibilityHelpUrl?: string;
        /**
         * Container element to use for ARIA messages.
         * Defaults to document.body.
         */
        ariaContainerElement?: HTMLElement;
    }

    /**
     * The options to create a diff editor.
     */
    export interface IStandaloneDiffEditorConstructionOptions extends IDiffEditorConstructionOptions {
        /**
         * Initial theme to be used for rendering.
         * The current out-of-the-box available themes are: &#x27;vs&#x27; (default), &#x27;vs-dark&#x27;, &#x27;hc-black&#x27;.
         * You can create custom themes via &#x60;monaco.editor.defineTheme&#x60;.
         * To switch a theme, use &#x60;monaco.editor.setTheme&#x60;.
         * **NOTE**: The theme might be overwritten if the OS is in high contrast mode, unless &#x60;autoDetectHighContrast&#x60; is set to false.
         */
        theme?: string;
        /**
         * If enabled, will automatically change to high contrast theme if the OS is using a high contrast theme.
         * Defaults to true.
         */
        autoDetectHighContrast?: boolean;
    }

    export interface IStandaloneCodeEditor extends ICodeEditor {
        updateOptions(newOptions: IEditorOptions &amp; IGlobalEditorOptions): void;
        addCommand(keybinding: number, handler: ICommandHandler, context?: string): string | null;
        createContextKey&lt;T&gt;(key: string, defaultValue: T): IContextKey&lt;T&gt;;
        addAction(descriptor: IActionDescriptor): IDisposable;
    }

    export interface IStandaloneDiffEditor extends IDiffEditor {
        addCommand(keybinding: number, handler: ICommandHandler, context?: string): string | null;
        createContextKey&lt;T&gt;(key: string, defaultValue: T): IContextKey&lt;T&gt;;
        addAction(descriptor: IActionDescriptor): IDisposable;
        getOriginalEditor(): IStandaloneCodeEditor;
        getModifiedEditor(): IStandaloneCodeEditor;
    }
    export interface ICommandHandler {
        (...args: any[]): void;
    }

    export interface IContextKey&lt;T&gt; {
        set(value: T): void;
        reset(): void;
        get(): T | undefined;
    }

    export interface IEditorOverrideServices {
        [index: string]: any;
    }

    export interface IMarker {
        owner: string;
        resource: Uri;
        severity: MarkerSeverity;
        code?: string | {
            value: string;
            target: Uri;
        };
        message: string;
        source?: string;
        startLineNumber: number;
        startColumn: number;
        endLineNumber: number;
        endColumn: number;
        relatedInformation?: IRelatedInformation[];
        tags?: MarkerTag[];
    }

    /**
     * A structure defining a problem/warning/etc.
     */
    export interface IMarkerData {
        code?: string | {
            value: string;
            target: Uri;
        };
        severity: MarkerSeverity;
        message: string;
        source?: string;
        startLineNumber: number;
        startColumn: number;
        endLineNumber: number;
        endColumn: number;
        relatedInformation?: IRelatedInformation[];
        tags?: MarkerTag[];
    }

    /**
     *
     */
    export interface IRelatedInformation {
        resource: Uri;
        message: string;
        startLineNumber: number;
        startColumn: number;
        endLineNumber: number;
        endColumn: number;
    }

    export interface IColorizerOptions {
        tabSize?: number;
    }

    export interface IColorizerElementOptions extends IColorizerOptions {
        theme?: string;
        mimeType?: string;
    }

    export enum ScrollbarVisibility {
        Auto &#x3D; 1,
        Hidden &#x3D; 2,
        Visible &#x3D; 3
    }

    export interface ThemeColor {
        id: string;
    }

    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    export enum OverviewRulerLane {
        Left &#x3D; 1,
        Center &#x3D; 2,
        Right &#x3D; 4,
        Full &#x3D; 7
    }

    /**
     * Position in the minimap to render the decoration.
     */
    export enum MinimapPosition {
        Inline &#x3D; 1,
        Gutter &#x3D; 2
    }

    export interface IDecorationOptions {
        /**
         * CSS color to render.
         * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
         */
        color: string | ThemeColor | undefined;
        /**
         * CSS color to render.
         * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
         */
        darkColor?: string | ThemeColor;
    }

    /**
     * Options for rendering a model decoration in the overview ruler.
     */
    export interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {
        /**
         * The position in the overview ruler.
         */
        position: OverviewRulerLane;
    }

    /**
     * Options for rendering a model decoration in the overview ruler.
     */
    export interface IModelDecorationMinimapOptions extends IDecorationOptions {
        /**
         * The position in the overview ruler.
         */
        position: MinimapPosition;
    }

    /**
     * Options for a model decoration.
     */
    export interface IModelDecorationOptions {
        /**
         * Customize the growing behavior of the decoration when typing at the edges of the decoration.
         * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
         */
        stickiness?: TrackedRangeStickiness;
        /**
         * CSS class name describing the decoration.
         */
        className?: string | null;
        /**
         * Message to be rendered when hovering over the glyph margin decoration.
         */
        glyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;
        /**
         * Array of MarkdownString to render as the decoration message.
         */
        hoverMessage?: IMarkdownString | IMarkdownString[] | null;
        /**
         * Should the decoration expand to encompass a whole line.
         */
        isWholeLine?: boolean;
        /**
         * Specifies the stack order of a decoration.
         * A decoration with greater stack order is always in front of a decoration with
         * a lower stack order when the decorations are on the same line.
         */
        zIndex?: number;
        /**
         * If set, render this decoration in the overview ruler.
         */
        overviewRuler?: IModelDecorationOverviewRulerOptions | null;
        /**
         * If set, render this decoration in the minimap.
         */
        minimap?: IModelDecorationMinimapOptions | null;
        /**
         * If set, the decoration will be rendered in the glyph margin with this CSS class name.
         */
        glyphMarginClassName?: string | null;
        /**
         * If set, the decoration will be rendered in the lines decorations with this CSS class name.
         */
        linesDecorationsClassName?: string | null;
        /**
         * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
         */
        firstLineDecorationClassName?: string | null;
        /**
         * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
         */
        marginClassName?: string | null;
        /**
         * If set, the decoration will be rendered inline with the text with this CSS class name.
         * Please use this only for CSS rules that must impact the text. For example, use &#x60;className&#x60;
         * to have a background color decoration.
         */
        inlineClassName?: string | null;
        /**
         * If there is an &#x60;inlineClassName&#x60; which affects letter spacing.
         */
        inlineClassNameAffectsLetterSpacing?: boolean;
        /**
         * If set, the decoration will be rendered before the text with this CSS class name.
         */
        beforeContentClassName?: string | null;
        /**
         * If set, the decoration will be rendered after the text with this CSS class name.
         */
        afterContentClassName?: string | null;
        /**
         * If set, text will be injected in the view after the range.
         */
        after?: InjectedTextOptions | null;
        /**
         * If set, text will be injected in the view before the range.
         */
        before?: InjectedTextOptions | null;
    }

    /**
     * Configures text that is injected into the view without changing the underlying document.
    */
    export interface InjectedTextOptions {
        /**
         * Sets the text to inject. Must be a single line.
         */
        readonly content: string;
        /**
         * If set, the decoration will be rendered inline with the text with this CSS class name.
         */
        readonly inlineClassName?: string | null;
        /**
         * If there is an &#x60;inlineClassName&#x60; which affects letter spacing.
         */
        readonly inlineClassNameAffectsLetterSpacing?: boolean;
    }

    /**
     * New model decorations.
     */
    export interface IModelDeltaDecoration {
        /**
         * Range that this decoration covers.
         */
        range: IRange;
        /**
         * Options associated with this decoration.
         */
        options: IModelDecorationOptions;
    }

    /**
     * A decoration in the model.
     */
    export interface IModelDecoration {
        /**
         * Identifier for a decoration.
         */
        readonly id: string;
        /**
         * Identifier for a decoration&#x27;s owner.
         */
        readonly ownerId: number;
        /**
         * Range that this decoration covers.
         */
        readonly range: Range;
        /**
         * Options associated with this decoration.
         */
        readonly options: IModelDecorationOptions;
    }

    /**
     * Word inside a model.
     */
    export interface IWordAtPosition {
        /**
         * The word.
         */
        readonly word: string;
        /**
         * The column where the word starts.
         */
        readonly startColumn: number;
        /**
         * The column where the word ends.
         */
        readonly endColumn: number;
    }

    /**
     * End of line character preference.
     */
    export enum EndOfLinePreference {
        /**
         * Use the end of line character identified in the text buffer.
         */
        TextDefined &#x3D; 0,
        /**
         * Use line feed (\n) as the end of line character.
         */
        LF &#x3D; 1,
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        CRLF &#x3D; 2
    }

    /**
     * The default end of line to use when instantiating models.
     */
    export enum DefaultEndOfLine {
        /**
         * Use line feed (\n) as the end of line character.
         */
        LF &#x3D; 1,
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        CRLF &#x3D; 2
    }

    /**
     * End of line character preference.
     */
    export enum EndOfLineSequence {
        /**
         * Use line feed (\n) as the end of line character.
         */
        LF &#x3D; 0,
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        CRLF &#x3D; 1
    }

    /**
     * A single edit operation, that acts as a simple replace.
     * i.e. Replace text at &#x60;range&#x60; with &#x60;text&#x60; in model.
     */
    export interface ISingleEditOperation {
        /**
         * The range to replace. This can be empty to emulate a simple insert.
         */
        range: IRange;
        /**
         * The text to replace with. This can be null to emulate a simple delete.
         */
        text: string | null;
        /**
         * This indicates that this operation has &quot;insert&quot; semantics.
         * i.e. forceMoveMarkers &#x3D; true &#x3D;&gt; if &#x60;range&#x60; is collapsed, all markers at the position will be moved.
         */
        forceMoveMarkers?: boolean;
    }

    /**
     * A single edit operation, that has an identifier.
     */
    export interface IIdentifiedSingleEditOperation {
        /**
         * The range to replace. This can be empty to emulate a simple insert.
         */
        range: IRange;
        /**
         * The text to replace with. This can be null to emulate a simple delete.
         */
        text: string | null;
        /**
         * This indicates that this operation has &quot;insert&quot; semantics.
         * i.e. forceMoveMarkers &#x3D; true &#x3D;&gt; if &#x60;range&#x60; is collapsed, all markers at the position will be moved.
         */
        forceMoveMarkers?: boolean;
    }

    export interface IValidEditOperation {
        /**
         * The range to replace. This can be empty to emulate a simple insert.
         */
        range: Range;
        /**
         * The text to replace with. This can be empty to emulate a simple delete.
         */
        text: string;
    }

    /**
     * A callback that can compute the cursor state after applying a series of edit operations.
     */
    export interface ICursorStateComputer {
        /**
         * A callback that can compute the resulting cursors state after some edit operations have been executed.
         */
        (inverseEditOperations: IValidEditOperation[]): Selection[] | null;
    }

    export class TextModelResolvedOptions {
        _textModelResolvedOptionsBrand: void;
        readonly tabSize: number;
        readonly indentSize: number;
        readonly insertSpaces: boolean;
        readonly defaultEOL: DefaultEndOfLine;
        readonly trimAutoWhitespace: boolean;
        readonly bracketPairColorizationOptions: BracketPairColorizationOptions;
    }

    export interface BracketPairColorizationOptions {
        enabled: boolean;
    }

    export interface ITextModelUpdateOptions {
        tabSize?: number;
        indentSize?: number;
        insertSpaces?: boolean;
        trimAutoWhitespace?: boolean;
        bracketColorizationOptions?: BracketPairColorizationOptions;
    }

    export class FindMatch {
        _findMatchBrand: void;
        readonly range: Range;
        readonly matches: string[] | null;
    }

    /**
     * Describes the behavior of decorations when typing/editing near their edges.
     * Note: Please do not edit the values, as they very carefully match &#x60;DecorationRangeBehavior&#x60;
     */
    export enum TrackedRangeStickiness {
        AlwaysGrowsWhenTypingAtEdges &#x3D; 0,
        NeverGrowsWhenTypingAtEdges &#x3D; 1,
        GrowsOnlyWhenTypingBefore &#x3D; 2,
        GrowsOnlyWhenTypingAfter &#x3D; 3
    }

    /**
     * A model.
     */
    export interface ITextModel {
        /**
         * Gets the resource associated with this editor model.
         */
        readonly uri: Uri;
        /**
         * A unique identifier associated with this model.
         */
        readonly id: string;
        /**
         * Get the resolved options for this model.
         */
        getOptions(): TextModelResolvedOptions;
        /**
         * Get the current version id of the model.
         * Anytime a change happens to the model (even undo/redo),
         * the version id is incremented.
         */
        getVersionId(): number;
        /**
         * Get the alternative version id of the model.
         * This alternative version id is not always incremented,
         * it will return the same values in the case of undo-redo.
         */
        getAlternativeVersionId(): number;
        /**
         * Replace the entire text buffer value contained in this model.
         */
        setValue(newValue: string): void;
        /**
         * Get the text stored in this model.
         * @param eol The end of line character preference. Defaults to &#x60;EndOfLinePreference.TextDefined&#x60;.
         * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
         * @return The text.
         */
        getValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;
        /**
         * Get the length of the text stored in this model.
         */
        getValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;
        /**
         * Get the text in a certain range.
         * @param range The range describing what text to get.
         * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to &#x60;EndOfLinePreference.TextDefined&#x60;.
         * @return The text.
         */
        getValueInRange(range: IRange, eol?: EndOfLinePreference): string;
        /**
         * Get the length of text in a certain range.
         * @param range The range describing what text length to get.
         * @return The text length.
         */
        getValueLengthInRange(range: IRange): number;
        /**
         * Get the character count of text in a certain range.
         * @param range The range describing what text length to get.
         */
        getCharacterCountInRange(range: IRange): number;
        /**
         * Get the number of lines in the model.
         */
        getLineCount(): number;
        /**
         * Get the text for a certain line.
         */
        getLineContent(lineNumber: number): string;
        /**
         * Get the text length for a certain line.
         */
        getLineLength(lineNumber: number): number;
        /**
         * Get the text for all lines.
         */
        getLinesContent(): string[];
        /**
         * Get the end of line sequence predominantly used in the text buffer.
         * @return EOL char sequence (e.g.: &#x27;\n&#x27; or &#x27;\r\n&#x27;).
         */
        getEOL(): string;
        /**
         * Get the end of line sequence predominantly used in the text buffer.
         */
        getEndOfLineSequence(): EndOfLineSequence;
        /**
         * Get the minimum legal column for line at &#x60;lineNumber&#x60;
         */
        getLineMinColumn(lineNumber: number): number;
        /**
         * Get the maximum legal column for line at &#x60;lineNumber&#x60;
         */
        getLineMaxColumn(lineNumber: number): number;
        /**
         * Returns the column before the first non whitespace character for line at &#x60;lineNumber&#x60;.
         * Returns 0 if line is empty or contains only whitespace.
         */
        getLineFirstNonWhitespaceColumn(lineNumber: number): number;
        /**
         * Returns the column after the last non whitespace character for line at &#x60;lineNumber&#x60;.
         * Returns 0 if line is empty or contains only whitespace.
         */
        getLineLastNonWhitespaceColumn(lineNumber: number): number;
        /**
         * Create a valid position.
         */
        validatePosition(position: IPosition): Position;
        /**
         * Advances the given position by the given offset (negative offsets are also accepted)
         * and returns it as a new valid position.
         *
         * If the offset and position are such that their combination goes beyond the beginning or
         * end of the model, throws an exception.
         *
         * If the offset is such that the new position would be in the middle of a multi-byte
         * line terminator, throws an exception.
         */
        modifyPosition(position: IPosition, offset: number): Position;
        /**
         * Create a valid range.
         */
        validateRange(range: IRange): Range;
        /**
         * Converts the position to a zero-based offset.
         *
         * The position will be [adjusted](#TextDocument.validatePosition).
         *
         * @param position A position.
         * @return A valid zero-based offset.
         */
        getOffsetAt(position: IPosition): number;
        /**
         * Converts a zero-based offset to a position.
         *
         * @param offset A zero-based offset.
         * @return A valid [position](#Position).
         */
        getPositionAt(offset: number): Position;
        /**
         * Get a range covering the entire model.
         */
        getFullModelRange(): Range;
        /**
         * Returns if the model was disposed or not.
         */
        isDisposed(): boolean;
        /**
         * Search the model.
         * @param searchString The string used to search. If it is a regular expression, set &#x60;isRegex&#x60; to true.
         * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
         * @param isRegex Used to indicate that &#x60;searchString&#x60; is a regular expression.
         * @param matchCase Force the matching to match lower/upper case exactly.
         * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
         * @param captureMatches The result will contain the captured groups.
         * @param limitResultCount Limit the number of results
         * @return The ranges where the matches are. It is empty if not matches have been found.
         */
        findMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];
        /**
         * Search the model.
         * @param searchString The string used to search. If it is a regular expression, set &#x60;isRegex&#x60; to true.
         * @param searchScope Limit the searching to only search inside these ranges.
         * @param isRegex Used to indicate that &#x60;searchString&#x60; is a regular expression.
         * @param matchCase Force the matching to match lower/upper case exactly.
         * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
         * @param captureMatches The result will contain the captured groups.
         * @param limitResultCount Limit the number of results
         * @return The ranges where the matches are. It is empty if no matches have been found.
         */
        findMatches(searchString: string, searchScope: IRange | IRange[], isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): FindMatch[];
        /**
         * Search the model for the next match. Loops to the beginning of the model if needed.
         * @param searchString The string used to search. If it is a regular expression, set &#x60;isRegex&#x60; to true.
         * @param searchStart Start the searching at the specified position.
         * @param isRegex Used to indicate that &#x60;searchString&#x60; is a regular expression.
         * @param matchCase Force the matching to match lower/upper case exactly.
         * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
         * @param captureMatches The result will contain the captured groups.
         * @return The range where the next match is. It is null if no next match has been found.
         */
        findNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;
        /**
         * Search the model for the previous match. Loops to the end of the model if needed.
         * @param searchString The string used to search. If it is a regular expression, set &#x60;isRegex&#x60; to true.
         * @param searchStart Start the searching at the specified position.
         * @param isRegex Used to indicate that &#x60;searchString&#x60; is a regular expression.
         * @param matchCase Force the matching to match lower/upper case exactly.
         * @param wordSeparators Force the matching to match entire words only. Pass null otherwise.
         * @param captureMatches The result will contain the captured groups.
         * @return The range where the previous match is. It is null if no previous match has been found.
         */
        findPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean): FindMatch | null;
        /**
         * Get the language associated with this model.
         */
        getLanguageId(): string;
        /**
         * Get the word under or besides &#x60;position&#x60;.
         * @param position The position to look for a word.
         * @return The word under or besides &#x60;position&#x60;. Might be null.
         */
        getWordAtPosition(position: IPosition): IWordAtPosition | null;
        /**
         * Get the word under or besides &#x60;position&#x60; trimmed to &#x60;position&#x60;.column
         * @param position The position to look for a word.
         * @return The word under or besides &#x60;position&#x60;. Will never be null.
         */
        getWordUntilPosition(position: IPosition): IWordAtPosition;
        /**
         * Perform a minimum amount of operations, in order to transform the decorations
         * identified by &#x60;oldDecorations&#x60; to the decorations described by &#x60;newDecorations&#x60;
         * and returns the new identifiers associated with the resulting decorations.
         *
         * @param oldDecorations Array containing previous decorations identifiers.
         * @param newDecorations Array describing what decorations should result after the call.
         * @param ownerId Identifies the editor id in which these decorations should appear. If no &#x60;ownerId&#x60; is provided, the decorations will appear in all editors that attach this model.
         * @return An array containing the new decorations identifiers.
         */
        deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];
        /**
         * Get the options associated with a decoration.
         * @param id The decoration id.
         * @return The decoration options or null if the decoration was not found.
         */
        getDecorationOptions(id: string): IModelDecorationOptions | null;
        /**
         * Get the range associated with a decoration.
         * @param id The decoration id.
         * @return The decoration range or null if the decoration was not found.
         */
        getDecorationRange(id: string): Range | null;
        /**
         * Gets all the decorations for the line &#x60;lineNumber&#x60; as an array.
         * @param lineNumber The line number
         * @param ownerId If set, it will ignore decorations belonging to other owners.
         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
         * @return An array with the decorations
         */
        getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
        /**
         * Gets all the decorations for the lines between &#x60;startLineNumber&#x60; and &#x60;endLineNumber&#x60; as an array.
         * @param startLineNumber The start line number
         * @param endLineNumber The end line number
         * @param ownerId If set, it will ignore decorations belonging to other owners.
         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
         * @return An array with the decorations
         */
        getLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
        /**
         * Gets all the decorations in a range as an array. Only &#x60;startLineNumber&#x60; and &#x60;endLineNumber&#x60; from &#x60;range&#x60; are used for filtering.
         * So for now it returns all the decorations on the same line as &#x60;range&#x60;.
         * @param range The range to search in
         * @param ownerId If set, it will ignore decorations belonging to other owners.
         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
         * @return An array with the decorations
         */
        getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
        /**
         * Gets all the decorations as an array.
         * @param ownerId If set, it will ignore decorations belonging to other owners.
         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
         */
        getAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
        /**
         * Gets all the decorations that should be rendered in the overview ruler as an array.
         * @param ownerId If set, it will ignore decorations belonging to other owners.
         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
         */
        getOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
        /**
         * Gets all the decorations that contain injected text.
         * @param ownerId If set, it will ignore decorations belonging to other owners.
         */
        getInjectedTextDecorations(ownerId?: number): IModelDecoration[];
        /**
         * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
         */
        normalizeIndentation(str: string): string;
        /**
         * Change the options of this model.
         */
        updateOptions(newOpts: ITextModelUpdateOptions): void;
        /**
         * Detect the indentation options for this model from its content.
         */
        detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
        /**
         * Close the current undo-redo element.
         * This offers a way to create an undo/redo stop point.
         */
        pushStackElement(): void;
        /**
         * Open the current undo-redo element.
         * This offers a way to remove the current undo/redo stop point.
         */
        popStackElement(): void;
        /**
         * Push edit operations, basically editing the model. This is the preferred way
         * of editing the model. The edit operations will land on the undo stack.
         * @param beforeCursorState The cursor state before the edit operations. This cursor state will be returned when &#x60;undo&#x60; or &#x60;redo&#x60; are invoked.
         * @param editOperations The edit operations.
         * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
         * @return The cursor state returned by the &#x60;cursorStateComputer&#x60;.
         */
        pushEditOperations(beforeCursorState: Selection[] | null, editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[] | null;
        /**
         * Change the end of line sequence. This is the preferred way of
         * changing the eol sequence. This will land on the undo stack.
         */
        pushEOL(eol: EndOfLineSequence): void;
        /**
         * Edit the model without adding the edits to the undo stack.
         * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
         * @param operations The edit operations.
         * @return If desired, the inverse edit operations, that, when applied, will bring the model back to the previous state.
         */
        applyEdits(operations: IIdentifiedSingleEditOperation[]): void;
        applyEdits(operations: IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;
        applyEdits(operations: IIdentifiedSingleEditOperation[], computeUndoEdits: true): IValidEditOperation[];
        /**
         * Change the end of line sequence without recording in the undo stack.
         * This can have dire consequences on the undo stack! See @pushEOL for the preferred way.
         */
        setEOL(eol: EndOfLineSequence): void;
        /**
         * An event emitted when the contents of the model have changed.
         * @event
         */
        onDidChangeContent(listener: (e: IModelContentChangedEvent) &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when decorations of the model have changed.
         * @event
         */
        onDidChangeDecorations(listener: (e: IModelDecorationsChangedEvent) &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the model options have changed.
         * @event
         */
        onDidChangeOptions(listener: (e: IModelOptionsChangedEvent) &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the language associated with the model has changed.
         * @event
         */
        onDidChangeLanguage(listener: (e: IModelLanguageChangedEvent) &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the language configuration associated with the model has changed.
         * @event
         */
        onDidChangeLanguageConfiguration(listener: (e: IModelLanguageConfigurationChangedEvent) &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the model has been attached to the first editor or detached from the last editor.
         * @event
         */
        onDidChangeAttached(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted right before disposing the model.
         * @event
         */
        onWillDispose(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * Destroy this model.
         */
        dispose(): void;
        /**
         * Returns if this model is attached to an editor or not.
         */
        isAttachedToEditor(): boolean;
    }

    /**
     * A builder and helper for edit operations for a command.
     */
    export interface IEditOperationBuilder {
        /**
         * Add a new edit operation (a replace operation).
         * @param range The range to replace (delete). May be empty to represent a simple insert.
         * @param text The text to replace with. May be null to represent a simple delete.
         */
        addEditOperation(range: IRange, text: string | null, forceMoveMarkers?: boolean): void;
        /**
         * Add a new edit operation (a replace operation).
         * The inverse edits will be accessible in &#x60;ICursorStateComputerData.getInverseEditOperations()&#x60;
         * @param range The range to replace (delete). May be empty to represent a simple insert.
         * @param text The text to replace with. May be null to represent a simple delete.
         */
        addTrackedEditOperation(range: IRange, text: string | null, forceMoveMarkers?: boolean): void;
        /**
         * Track &#x60;selection&#x60; when applying edit operations.
         * A best effort will be made to not grow/expand the selection.
         * An empty selection will clamp to a nearby character.
         * @param selection The selection to track.
         * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection
         *           should clamp to the previous or the next character.
         * @return A unique identifier.
         */
        trackSelection(selection: Selection, trackPreviousOnEmpty?: boolean): string;
    }

    /**
     * A helper for computing cursor state after a command.
     */
    export interface ICursorStateComputerData {
        /**
         * Get the inverse edit operations of the added edit operations.
         */
        getInverseEditOperations(): IValidEditOperation[];
        /**
         * Get a previously tracked selection.
         * @param id The unique identifier returned by &#x60;trackSelection&#x60;.
         * @return The selection.
         */
        getTrackedSelection(id: string): Selection;
    }

    /**
     * A command that modifies text / cursor state on a model.
     */
    export interface ICommand {
        /**
         * Get the edit operations needed to execute this command.
         * @param model The model the command will execute on.
         * @param builder A helper to collect the needed edit operations and to track selections.
         */
        getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void;
        /**
         * Compute the cursor state after the edit operations were applied.
         * @param model The model the command has executed on.
         * @param helper A helper to get inverse edit operations and to get previously tracked selections.
         * @return The cursor state after the command executed.
         */
        computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection;
    }

    /**
     * A model for the diff editor.
     */
    export interface IDiffEditorModel {
        /**
         * Original model.
         */
        original: ITextModel;
        /**
         * Modified model.
         */
        modified: ITextModel;
    }

    /**
     * An event describing that an editor has had its model reset (i.e. &#x60;editor.setModel()&#x60;).
     */
    export interface IModelChangedEvent {
        /**
         * The &#x60;uri&#x60; of the previous model or null.
         */
        readonly oldModelUrl: Uri | null;
        /**
         * The &#x60;uri&#x60; of the new model or null.
         */
        readonly newModelUrl: Uri | null;
    }

    export interface IDimension {
        width: number;
        height: number;
    }

    /**
     * A change
     */
    export interface IChange {
        readonly originalStartLineNumber: number;
        readonly originalEndLineNumber: number;
        readonly modifiedStartLineNumber: number;
        readonly modifiedEndLineNumber: number;
    }

    /**
     * A character level change.
     */
    export interface ICharChange extends IChange {
        readonly originalStartColumn: number;
        readonly originalEndColumn: number;
        readonly modifiedStartColumn: number;
        readonly modifiedEndColumn: number;
    }

    /**
     * A line change
     */
    export interface ILineChange extends IChange {
        readonly charChanges: ICharChange[] | undefined;
    }

    export interface IContentSizeChangedEvent {
        readonly contentWidth: number;
        readonly contentHeight: number;
        readonly contentWidthChanged: boolean;
        readonly contentHeightChanged: boolean;
    }

    export interface INewScrollPosition {
        scrollLeft?: number;
        scrollTop?: number;
    }

    export interface IEditorAction {
        readonly id: string;
        readonly label: string;
        readonly alias: string;
        isSupported(): boolean;
        run(): Promise&lt;void&gt;;
    }

    export type IEditorModel &#x3D; ITextModel | IDiffEditorModel;

    /**
     * A (serializable) state of the cursors.
     */
    export interface ICursorState {
        inSelectionMode: boolean;
        selectionStart: IPosition;
        position: IPosition;
    }

    /**
     * A (serializable) state of the view.
     */
    export interface IViewState {
        /** written by previous versions */
        scrollTop?: number;
        /** written by previous versions */
        scrollTopWithoutViewZones?: number;
        scrollLeft: number;
        firstPosition: IPosition;
        firstPositionDeltaTop: number;
    }

    /**
     * A (serializable) state of the code editor.
     */
    export interface ICodeEditorViewState {
        cursorState: ICursorState[];
        viewState: IViewState;
        contributionsState: {
            [id: string]: any;
        };
    }

    /**
     * (Serializable) View state for the diff editor.
     */
    export interface IDiffEditorViewState {
        original: ICodeEditorViewState | null;
        modified: ICodeEditorViewState | null;
    }

    /**
     * An editor view state.
     */
    export type IEditorViewState &#x3D; ICodeEditorViewState | IDiffEditorViewState;

    export enum ScrollType {
        Smooth &#x3D; 0,
        Immediate &#x3D; 1
    }

    /**
     * An editor.
     */
    export interface IEditor {
        /**
         * An event emitted when the editor has been disposed.
         * @event
         */
        onDidDispose(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * Dispose the editor.
         */
        dispose(): void;
        /**
         * Get a unique id for this editor instance.
         */
        getId(): string;
        /**
         * Get the editor type. Please see &#x60;EditorType&#x60;.
         * This is to avoid an instanceof check
         */
        getEditorType(): string;
        /**
         * Update the editor&#x27;s options after the editor has been created.
         */
        updateOptions(newOptions: IEditorOptions): void;
        /**
         * Instructs the editor to remeasure its container. This method should
         * be called when the container of the editor gets resized.
         *
         * If a dimension is passed in, the passed in value will be used.
         */
        layout(dimension?: IDimension): void;
        /**
         * Brings browser focus to the editor text
         */
        focus(): void;
        /**
         * Returns true if the text inside this editor is focused (i.e. cursor is blinking).
         */
        hasTextFocus(): boolean;
        /**
         * Returns all actions associated with this editor.
         */
        getSupportedActions(): IEditorAction[];
        /**
         * Saves current view state of the editor in a serializable object.
         */
        saveViewState(): IEditorViewState | null;
        /**
         * Restores the view state of the editor from a serializable object generated by &#x60;saveViewState&#x60;.
         */
        restoreViewState(state: IEditorViewState): void;
        /**
         * Given a position, returns a column number that takes tab-widths into account.
         */
        getVisibleColumnFromPosition(position: IPosition): number;
        /**
         * Returns the primary position of the cursor.
         */
        getPosition(): Position | null;
        /**
         * Set the primary position of the cursor. This will remove any secondary cursors.
         * @param position New primary cursor&#x27;s position
         */
        setPosition(position: IPosition): void;
        /**
         * Scroll vertically as necessary and reveal a line.
         */
        revealLine(lineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically as necessary and reveal a line centered vertically.
         */
        revealLineInCenter(lineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
         */
        revealLineInCenterIfOutsideViewport(lineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically as necessary and reveal a line close to the top of the viewport,
         * optimized for viewing a code definition.
         */
        revealLineNearTop(lineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a position.
         */
        revealPosition(position: IPosition, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
         */
        revealPositionInCenter(position: IPosition, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
         */
        revealPositionInCenterIfOutsideViewport(position: IPosition, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a position close to the top of the viewport,
         * optimized for viewing a code definition.
         */
        revealPositionNearTop(position: IPosition, scrollType?: ScrollType): void;
        /**
         * Returns the primary selection of the editor.
         */
        getSelection(): Selection | null;
        /**
         * Returns all the selections of the editor.
         */
        getSelections(): Selection[] | null;
        /**
         * Set the primary selection of the editor. This will remove any secondary cursors.
         * @param selection The new selection
         */
        setSelection(selection: IRange): void;
        /**
         * Set the primary selection of the editor. This will remove any secondary cursors.
         * @param selection The new selection
         */
        setSelection(selection: Range): void;
        /**
         * Set the primary selection of the editor. This will remove any secondary cursors.
         * @param selection The new selection
         */
        setSelection(selection: ISelection): void;
        /**
         * Set the primary selection of the editor. This will remove any secondary cursors.
         * @param selection The new selection
         */
        setSelection(selection: Selection): void;
        /**
         * Set the selections for all the cursors of the editor.
         * Cursors will be removed or added, as necessary.
         */
        setSelections(selections: readonly ISelection[]): void;
        /**
         * Scroll vertically as necessary and reveal lines.
         */
        revealLines(startLineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically as necessary and reveal lines centered vertically.
         */
        revealLinesInCenter(lineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
         */
        revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically as necessary and reveal lines close to the top of the viewport,
         * optimized for viewing a code definition.
         */
        revealLinesNearTop(lineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a range.
         */
        revealRange(range: IRange, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
         */
        revealRangeInCenter(range: IRange, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
         */
        revealRangeAtTop(range: IRange, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
         */
        revealRangeInCenterIfOutsideViewport(range: IRange, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
         * optimized for viewing a code definition.
         */
        revealRangeNearTop(range: IRange, scrollType?: ScrollType): void;
        /**
         * Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
         * optimized for viewing a code definition. Only if it lies outside the viewport.
         */
        revealRangeNearTopIfOutsideViewport(range: IRange, scrollType?: ScrollType): void;
        /**
         * Directly trigger a handler or an editor action.
         * @param source The source of the call.
         * @param handlerId The id of the handler or the id of a contribution.
         * @param payload Extra data to be sent to the handler.
         */
        trigger(source: string | null | undefined, handlerId: string, payload: any): void;
        /**
         * Gets the current model attached to this editor.
         */
        getModel(): IEditorModel | null;
        /**
         * Sets the current model attached to this editor.
         * If the previous model was created by the editor via the value key in the options
         * literal object, it will be destroyed. Otherwise, if the previous model was set
         * via setModel, or the model key in the options literal object, the previous model
         * will not be destroyed.
         * It is safe to call setModel(null) to simply detach the current model from the editor.
         */
        setModel(model: IEditorModel | null): void;
    }

    /**
     * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
     */
    export interface IEditorContribution {
        /**
         * Dispose this contribution.
         */
        dispose(): void;
        /**
         * Store view state.
         */
        saveViewState?(): any;
        /**
         * Restore view state.
         */
        restoreViewState?(state: any): void;
    }

    /**
     * The type of the &#x60;IEditor&#x60;.
     */
    export const EditorType: {
        ICodeEditor: string;
        IDiffEditor: string;
    };

    /**
     * An event describing that the current language associated with a model has changed.
     */
    export interface IModelLanguageChangedEvent {
        /**
         * Previous language
         */
        readonly oldLanguage: string;
        /**
         * New language
         */
        readonly newLanguage: string;
    }

    /**
     * An event describing that the language configuration associated with a model has changed.
     */
    export interface IModelLanguageConfigurationChangedEvent {
    }

    export interface IModelContentChange {
        /**
         * The range that got replaced.
         */
        readonly range: IRange;
        /**
         * The offset of the range that got replaced.
         */
        readonly rangeOffset: number;
        /**
         * The length of the range that got replaced.
         */
        readonly rangeLength: number;
        /**
         * The new text for the range.
         */
        readonly text: string;
    }

    /**
     * An event describing a change in the text of a model.
     */
    export interface IModelContentChangedEvent {
        readonly changes: IModelContentChange[];
        /**
         * The (new) end-of-line character.
         */
        readonly eol: string;
        /**
         * The new version id the model has transitioned to.
         */
        readonly versionId: number;
        /**
         * Flag that indicates that this event was generated while undoing.
         */
        readonly isUndoing: boolean;
        /**
         * Flag that indicates that this event was generated while redoing.
         */
        readonly isRedoing: boolean;
        /**
         * Flag that indicates that all decorations were lost with this edit.
         * The model has been reset to a new value.
         */
        readonly isFlush: boolean;
    }

    /**
     * An event describing that model decorations have changed.
     */
    export interface IModelDecorationsChangedEvent {
        readonly affectsMinimap: boolean;
        readonly affectsOverviewRuler: boolean;
    }

    export interface IModelOptionsChangedEvent {
        readonly tabSize: boolean;
        readonly indentSize: boolean;
        readonly insertSpaces: boolean;
        readonly trimAutoWhitespace: boolean;
    }

    /**
     * Describes the reason the cursor has changed its position.
     */
    export enum CursorChangeReason {
        /**
         * Unknown or not set.
         */
        NotSet &#x3D; 0,
        /**
         * A &#x60;model.setValue()&#x60; was called.
         */
        ContentFlush &#x3D; 1,
        /**
         * The &#x60;model&#x60; has been changed outside of this cursor and the cursor recovers its position from associated markers.
         */
        RecoverFromMarkers &#x3D; 2,
        /**
         * There was an explicit user gesture.
         */
        Explicit &#x3D; 3,
        /**
         * There was a Paste.
         */
        Paste &#x3D; 4,
        /**
         * There was an Undo.
         */
        Undo &#x3D; 5,
        /**
         * There was a Redo.
         */
        Redo &#x3D; 6
    }

    /**
     * An event describing that the cursor position has changed.
     */
    export interface ICursorPositionChangedEvent {
        /**
         * Primary cursor&#x27;s position.
         */
        readonly position: Position;
        /**
         * Secondary cursors&#x27; position.
         */
        readonly secondaryPositions: Position[];
        /**
         * Reason.
         */
        readonly reason: CursorChangeReason;
        /**
         * Source of the call that caused the event.
         */
        readonly source: string;
    }

    /**
     * An event describing that the cursor selection has changed.
     */
    export interface ICursorSelectionChangedEvent {
        /**
         * The primary selection.
         */
        readonly selection: Selection;
        /**
         * The secondary selections.
         */
        readonly secondarySelections: Selection[];
        /**
         * The model version id.
         */
        readonly modelVersionId: number;
        /**
         * The old selections.
         */
        readonly oldSelections: Selection[] | null;
        /**
         * The model version id the that &#x60;oldSelections&#x60; refer to.
         */
        readonly oldModelVersionId: number;
        /**
         * Source of the call that caused the event.
         */
        readonly source: string;
        /**
         * Reason.
         */
        readonly reason: CursorChangeReason;
    }

    export enum AccessibilitySupport {
        /**
         * This should be the browser case where it is not known if a screen reader is attached or no.
         */
        Unknown &#x3D; 0,
        Disabled &#x3D; 1,
        Enabled &#x3D; 2
    }

    /**
     * Configuration options for auto closing quotes and brackets
     */
    export type EditorAutoClosingStrategy &#x3D; &#x27;always&#x27; | &#x27;languageDefined&#x27; | &#x27;beforeWhitespace&#x27; | &#x27;never&#x27;;

    /**
     * Configuration options for auto wrapping quotes and brackets
     */
    export type EditorAutoSurroundStrategy &#x3D; &#x27;languageDefined&#x27; | &#x27;quotes&#x27; | &#x27;brackets&#x27; | &#x27;never&#x27;;

    /**
     * Configuration options for typing over closing quotes or brackets
     */
    export type EditorAutoClosingEditStrategy &#x3D; &#x27;always&#x27; | &#x27;auto&#x27; | &#x27;never&#x27;;

    /**
     * Configuration options for auto indentation in the editor
     */
    export enum EditorAutoIndentStrategy {
        None &#x3D; 0,
        Keep &#x3D; 1,
        Brackets &#x3D; 2,
        Advanced &#x3D; 3,
        Full &#x3D; 4
    }

    /**
     * Configuration options for the editor.
     */
    export interface IEditorOptions {
        /**
         * This editor is used inside a diff editor.
         */
        inDiffEditor?: boolean;
        /**
         * The aria label for the editor&#x27;s textarea (when it is focused).
         */
        ariaLabel?: string;
        /**
         * The &#x60;tabindex&#x60; property of the editor&#x27;s textarea
         */
        tabIndex?: number;
        /**
         * Render vertical lines at the specified columns.
         * Defaults to empty array.
         */
        rulers?: (number | IRulerOption)[];
        /**
         * A string containing the word separators used when doing word navigation.
         * Defaults to &#x60;~!@#$%^&amp;*()-&#x3D;+[{]}\\|;:\&#x27;&quot;,.&lt;&gt;/?
         */
        wordSeparators?: string;
        /**
         * Enable Linux primary clipboard.
         * Defaults to true.
         */
        selectionClipboard?: boolean;
        /**
         * Control the rendering of line numbers.
         * If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
         * Otherwise, if it is a truthy, line numbers will be rendered normally (equivalent of using an identity function).
         * Otherwise, line numbers will not be rendered.
         * Defaults to &#x60;on&#x60;.
         */
        lineNumbers?: LineNumbersType;
        /**
         * Controls the minimal number of visible leading and trailing lines surrounding the cursor.
         * Defaults to 0.
        */
        cursorSurroundingLines?: number;
        /**
         * Controls when &#x60;cursorSurroundingLines&#x60; should be enforced
         * Defaults to &#x60;default&#x60;, &#x60;cursorSurroundingLines&#x60; is not enforced when cursor position is changed
         * by mouse.
        */
        cursorSurroundingLinesStyle?: &#x27;default&#x27; | &#x27;all&#x27;;
        /**
         * Render last line number when the file ends with a newline.
         * Defaults to true.
        */
        renderFinalNewline?: boolean;
        /**
         * Remove unusual line terminators like LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).
         * Defaults to &#x27;prompt&#x27;.
         */
        unusualLineTerminators?: &#x27;auto&#x27; | &#x27;off&#x27; | &#x27;prompt&#x27;;
        /**
         * Should the corresponding line be selected when clicking on the line number?
         * Defaults to true.
         */
        selectOnLineNumbers?: boolean;
        /**
         * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
         * Defaults to 5.
         */
        lineNumbersMinChars?: number;
        /**
         * Enable the rendering of the glyph margin.
         * Defaults to true in vscode and to false in monaco-editor.
         */
        glyphMargin?: boolean;
        /**
         * The width reserved for line decorations (in px).
         * Line decorations are placed between line numbers and the editor content.
         * You can pass in a string in the format floating point followed by &quot;ch&quot;. e.g. 1.3ch.
         * Defaults to 10.
         */
        lineDecorationsWidth?: number | string;
        /**
         * When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
         * This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
         * Defaults to 30 (px).
         */
        revealHorizontalRightPadding?: number;
        /**
         * Render the editor selection with rounded borders.
         * Defaults to true.
         */
        roundedSelection?: boolean;
        /**
         * Class name to be added to the editor.
         */
        extraEditorClassName?: string;
        /**
         * Should the editor be read only. See also &#x60;domReadOnly&#x60;.
         * Defaults to false.
         */
        readOnly?: boolean;
        /**
         * Should the textarea used for input use the DOM &#x60;readonly&#x60; attribute.
         * Defaults to false.
         */
        domReadOnly?: boolean;
        /**
         * Enable linked editing.
         * Defaults to false.
         */
        linkedEditing?: boolean;
        /**
         * deprecated, use linkedEditing instead
         */
        renameOnType?: boolean;
        /**
         * Should the editor render validation decorations.
         * Defaults to editable.
         */
        renderValidationDecorations?: &#x27;editable&#x27; | &#x27;on&#x27; | &#x27;off&#x27;;
        /**
         * Control the behavior and rendering of the scrollbars.
         */
        scrollbar?: IEditorScrollbarOptions;
        /**
         * Control the behavior and rendering of the minimap.
         */
        minimap?: IEditorMinimapOptions;
        /**
         * Control the behavior of the find widget.
         */
        find?: IEditorFindOptions;
        /**
         * Display overflow widgets as &#x60;fixed&#x60;.
         * Defaults to &#x60;false&#x60;.
         */
        fixedOverflowWidgets?: boolean;
        /**
         * The number of vertical lanes the overview ruler should render.
         * Defaults to 3.
         */
        overviewRulerLanes?: number;
        /**
         * Controls if a border should be drawn around the overview ruler.
         * Defaults to &#x60;true&#x60;.
         */
        overviewRulerBorder?: boolean;
        /**
         * Control the cursor animation style, possible values are &#x27;blink&#x27;, &#x27;smooth&#x27;, &#x27;phase&#x27;, &#x27;expand&#x27; and &#x27;solid&#x27;.
         * Defaults to &#x27;blink&#x27;.
         */
        cursorBlinking?: &#x27;blink&#x27; | &#x27;smooth&#x27; | &#x27;phase&#x27; | &#x27;expand&#x27; | &#x27;solid&#x27;;
        /**
         * Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
         * Defaults to false.
         */
        mouseWheelZoom?: boolean;
        /**
         * Control the mouse pointer style, either &#x27;text&#x27; or &#x27;default&#x27; or &#x27;copy&#x27;
         * Defaults to &#x27;text&#x27;
         */
        mouseStyle?: &#x27;text&#x27; | &#x27;default&#x27; | &#x27;copy&#x27;;
        /**
         * Enable smooth caret animation.
         * Defaults to false.
         */
        cursorSmoothCaretAnimation?: boolean;
        /**
         * Control the cursor style, either &#x27;block&#x27; or &#x27;line&#x27;.
         * Defaults to &#x27;line&#x27;.
         */
        cursorStyle?: &#x27;line&#x27; | &#x27;block&#x27; | &#x27;underline&#x27; | &#x27;line-thin&#x27; | &#x27;block-outline&#x27; | &#x27;underline-thin&#x27;;
        /**
         * Control the width of the cursor when cursorStyle is set to &#x27;line&#x27;
         */
        cursorWidth?: number;
        /**
         * Enable font ligatures.
         * Defaults to false.
         */
        fontLigatures?: boolean | string;
        /**
         * Disable the use of &#x60;transform: translate3d(0px, 0px, 0px)&#x60; for the editor margin and lines layers.
         * The usage of &#x60;transform: translate3d(0px, 0px, 0px)&#x60; acts as a hint for browsers to create an extra layer.
         * Defaults to false.
         */
        disableLayerHinting?: boolean;
        /**
         * Disable the optimizations for monospace fonts.
         * Defaults to false.
         */
        disableMonospaceOptimizations?: boolean;
        /**
         * Should the cursor be hidden in the overview ruler.
         * Defaults to false.
         */
        hideCursorInOverviewRuler?: boolean;
        /**
         * Enable that scrolling can go one screen size after the last line.
         * Defaults to true.
         */
        scrollBeyondLastLine?: boolean;
        /**
         * Enable that scrolling can go beyond the last column by a number of columns.
         * Defaults to 5.
         */
        scrollBeyondLastColumn?: number;
        /**
         * Enable that the editor animates scrolling to a position.
         * Defaults to false.
         */
        smoothScrolling?: boolean;
        /**
         * Enable that the editor will install an interval to check if its container dom node size has changed.
         * Enabling this might have a severe performance impact.
         * Defaults to false.
         */
        automaticLayout?: boolean;
        /**
         * Control the wrapping of the editor.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;off&quot;, the lines will never wrap.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;on&quot;, the lines will wrap at the viewport width.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;wordWrapColumn&quot;, the lines will wrap at &#x60;wordWrapColumn&#x60;.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;bounded&quot;, the lines will wrap at min(viewport width, wordWrapColumn).
         * Defaults to &quot;off&quot;.
         */
        wordWrap?: &#x27;off&#x27; | &#x27;on&#x27; | &#x27;wordWrapColumn&#x27; | &#x27;bounded&#x27;;
        /**
         * Override the &#x60;wordWrap&#x60; setting.
         */
        wordWrapOverride1?: &#x27;off&#x27; | &#x27;on&#x27; | &#x27;inherit&#x27;;
        /**
         * Override the &#x60;wordWrapOverride1&#x60; setting.
         */
        wordWrapOverride2?: &#x27;off&#x27; | &#x27;on&#x27; | &#x27;inherit&#x27;;
        /**
         * Control the wrapping of the editor.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;off&quot;, the lines will never wrap.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;on&quot;, the lines will wrap at the viewport width.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;wordWrapColumn&quot;, the lines will wrap at &#x60;wordWrapColumn&#x60;.
         * When &#x60;wordWrap&#x60; &#x3D; &quot;bounded&quot;, the lines will wrap at min(viewport width, wordWrapColumn).
         * Defaults to 80.
         */
        wordWrapColumn?: number;
        /**
         * Control indentation of wrapped lines. Can be: &#x27;none&#x27;, &#x27;same&#x27;, &#x27;indent&#x27; or &#x27;deepIndent&#x27;.
         * Defaults to &#x27;same&#x27; in vscode and to &#x27;none&#x27; in monaco-editor.
         */
        wrappingIndent?: &#x27;none&#x27; | &#x27;same&#x27; | &#x27;indent&#x27; | &#x27;deepIndent&#x27;;
        /**
         * Controls the wrapping strategy to use.
         * Defaults to &#x27;simple&#x27;.
         */
        wrappingStrategy?: &#x27;simple&#x27; | &#x27;advanced&#x27;;
        /**
         * Configure word wrapping characters. A break will be introduced before these characters.
         */
        wordWrapBreakBeforeCharacters?: string;
        /**
         * Configure word wrapping characters. A break will be introduced after these characters.
         */
        wordWrapBreakAfterCharacters?: string;
        /**
         * Performance guard: Stop rendering a line after x characters.
         * Defaults to 10000.
         * Use -1 to never stop rendering
         */
        stopRenderingLineAfter?: number;
        /**
         * Configure the editor&#x27;s hover.
         */
        hover?: IEditorHoverOptions;
        /**
         * Enable detecting links and making them clickable.
         * Defaults to true.
         */
        links?: boolean;
        /**
         * Enable inline color decorators and color picker rendering.
         */
        colorDecorators?: boolean;
        /**
         * Control the behaviour of comments in the editor.
         */
        comments?: IEditorCommentsOptions;
        /**
         * Enable custom contextmenu.
         * Defaults to true.
         */
        contextmenu?: boolean;
        /**
         * A multiplier to be used on the &#x60;deltaX&#x60; and &#x60;deltaY&#x60; of mouse wheel scroll events.
         * Defaults to 1.
         */
        mouseWheelScrollSensitivity?: number;
        /**
         * FastScrolling mulitplier speed when pressing &#x60;Alt&#x60;
         * Defaults to 5.
         */
        fastScrollSensitivity?: number;
        /**
         * Enable that the editor scrolls only the predominant axis. Prevents horizontal drift when scrolling vertically on a trackpad.
         * Defaults to true.
         */
        scrollPredominantAxis?: boolean;
        /**
         * Enable that the selection with the mouse and keys is doing column selection.
         * Defaults to false.
         */
        columnSelection?: boolean;
        /**
         * The modifier to be used to add multiple cursors with the mouse.
         * Defaults to &#x27;alt&#x27;
         */
        multiCursorModifier?: &#x27;ctrlCmd&#x27; | &#x27;alt&#x27;;
        /**
         * Merge overlapping selections.
         * Defaults to true
         */
        multiCursorMergeOverlapping?: boolean;
        /**
         * Configure the behaviour when pasting a text with the line count equal to the cursor count.
         * Defaults to &#x27;spread&#x27;.
         */
        multiCursorPaste?: &#x27;spread&#x27; | &#x27;full&#x27;;
        /**
         * Configure the editor&#x27;s accessibility support.
         * Defaults to &#x27;auto&#x27;. It is best to leave this to &#x27;auto&#x27;.
         */
        accessibilitySupport?: &#x27;auto&#x27; | &#x27;off&#x27; | &#x27;on&#x27;;
        /**
         * Controls the number of lines in the editor that can be read out by a screen reader
         */
        accessibilityPageSize?: number;
        /**
         * Suggest options.
         */
        suggest?: ISuggestOptions;
        inlineSuggest?: IInlineSuggestOptions;
        /**
         * Smart select options.
         */
        smartSelect?: ISmartSelectOptions;
        /**
         *
         */
        gotoLocation?: IGotoLocationOptions;
        /**
         * Enable quick suggestions (shadow suggestions)
         * Defaults to true.
         */
        quickSuggestions?: boolean | IQuickSuggestionsOptions;
        /**
         * Quick suggestions show delay (in ms)
         * Defaults to 10 (ms)
         */
        quickSuggestionsDelay?: number;
        /**
         * Controls the spacing around the editor.
         */
        padding?: IEditorPaddingOptions;
        /**
         * Parameter hint options.
         */
        parameterHints?: IEditorParameterHintOptions;
        /**
         * Options for auto closing brackets.
         * Defaults to language defined behavior.
         */
        autoClosingBrackets?: EditorAutoClosingStrategy;
        /**
         * Options for auto closing quotes.
         * Defaults to language defined behavior.
         */
        autoClosingQuotes?: EditorAutoClosingStrategy;
        /**
         * Options for pressing backspace near quotes or bracket pairs.
         */
        autoClosingDelete?: EditorAutoClosingEditStrategy;
        /**
         * Options for typing over closing quotes or brackets.
         */
        autoClosingOvertype?: EditorAutoClosingEditStrategy;
        /**
         * Options for auto surrounding.
         * Defaults to always allowing auto surrounding.
         */
        autoSurround?: EditorAutoSurroundStrategy;
        /**
         * Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.
         * Defaults to advanced.
         */
        autoIndent?: &#x27;none&#x27; | &#x27;keep&#x27; | &#x27;brackets&#x27; | &#x27;advanced&#x27; | &#x27;full&#x27;;
        /**
         * Emulate selection behaviour of tab characters when using spaces for indentation.
         * This means selection will stick to tab stops.
         */
        stickyTabStops?: boolean;
        /**
         * Enable format on type.
         * Defaults to false.
         */
        formatOnType?: boolean;
        /**
         * Enable format on paste.
         * Defaults to false.
         */
        formatOnPaste?: boolean;
        /**
         * Controls if the editor should allow to move selections via drag and drop.
         * Defaults to false.
         */
        dragAndDrop?: boolean;
        /**
         * Enable the suggestion box to pop-up on trigger characters.
         * Defaults to true.
         */
        suggestOnTriggerCharacters?: boolean;
        /**
         * Accept suggestions on ENTER.
         * Defaults to &#x27;on&#x27;.
         */
        acceptSuggestionOnEnter?: &#x27;on&#x27; | &#x27;smart&#x27; | &#x27;off&#x27;;
        /**
         * Accept suggestions on provider defined characters.
         * Defaults to true.
         */
        acceptSuggestionOnCommitCharacter?: boolean;
        /**
         * Enable snippet suggestions. Default to &#x27;true&#x27;.
         */
        snippetSuggestions?: &#x27;top&#x27; | &#x27;bottom&#x27; | &#x27;inline&#x27; | &#x27;none&#x27;;
        /**
         * Copying without a selection copies the current line.
         */
        emptySelectionClipboard?: boolean;
        /**
         * Syntax highlighting is copied.
         */
        copyWithSyntaxHighlighting?: boolean;
        /**
         * The history mode for suggestions.
         */
        suggestSelection?: &#x27;first&#x27; | &#x27;recentlyUsed&#x27; | &#x27;recentlyUsedByPrefix&#x27;;
        /**
         * The font size for the suggest widget.
         * Defaults to the editor font size.
         */
        suggestFontSize?: number;
        /**
         * The line height for the suggest widget.
         * Defaults to the editor line height.
         */
        suggestLineHeight?: number;
        /**
         * Enable tab completion.
         */
        tabCompletion?: &#x27;on&#x27; | &#x27;off&#x27; | &#x27;onlySnippets&#x27;;
        /**
         * Enable selection highlight.
         * Defaults to true.
         */
        selectionHighlight?: boolean;
        /**
         * Enable semantic occurrences highlight.
         * Defaults to true.
         */
        occurrencesHighlight?: boolean;
        /**
         * Show code lens
         * Defaults to true.
         */
        codeLens?: boolean;
        /**
         * Code lens font family. Defaults to editor font family.
         */
        codeLensFontFamily?: string;
        /**
         * Code lens font size. Default to 90% of the editor font size
         */
        codeLensFontSize?: number;
        /**
         * Control the behavior and rendering of the code action lightbulb.
         */
        lightbulb?: IEditorLightbulbOptions;
        /**
         * Timeout for running code actions on save.
         */
        codeActionsOnSaveTimeout?: number;
        /**
         * Enable code folding.
         * Defaults to true.
         */
        folding?: boolean;
        /**
         * Selects the folding strategy. &#x27;auto&#x27; uses the strategies contributed for the current document, &#x27;indentation&#x27; uses the indentation based folding strategy.
         * Defaults to &#x27;auto&#x27;.
         */
        foldingStrategy?: &#x27;auto&#x27; | &#x27;indentation&#x27;;
        /**
         * Enable highlight for folded regions.
         * Defaults to true.
         */
        foldingHighlight?: boolean;
        /**
         * Auto fold imports folding regions.
         * Defaults to true.
         */
        foldingImportsByDefault?: boolean;
        /**
         * Controls whether the fold actions in the gutter stay always visible or hide unless the mouse is over the gutter.
         * Defaults to &#x27;mouseover&#x27;.
         */
        showFoldingControls?: &#x27;always&#x27; | &#x27;mouseover&#x27;;
        /**
         * Controls whether clicking on the empty content after a folded line will unfold the line.
         * Defaults to false.
         */
        unfoldOnClickAfterEndOfLine?: boolean;
        /**
         * Enable highlighting of matching brackets.
         * Defaults to &#x27;always&#x27;.
         */
        matchBrackets?: &#x27;never&#x27; | &#x27;near&#x27; | &#x27;always&#x27;;
        /**
         * Enable rendering of whitespace.
         * Defaults to &#x27;selection&#x27;.
         */
        renderWhitespace?: &#x27;none&#x27; | &#x27;boundary&#x27; | &#x27;selection&#x27; | &#x27;trailing&#x27; | &#x27;all&#x27;;
        /**
         * Enable rendering of control characters.
         * Defaults to true.
         */
        renderControlCharacters?: boolean;
        /**
         * Enable rendering of current line highlight.
         * Defaults to all.
         */
        renderLineHighlight?: &#x27;none&#x27; | &#x27;gutter&#x27; | &#x27;line&#x27; | &#x27;all&#x27;;
        /**
         * Control if the current line highlight should be rendered only the editor is focused.
         * Defaults to false.
         */
        renderLineHighlightOnlyWhenFocus?: boolean;
        /**
         * Inserting and deleting whitespace follows tab stops.
         */
        useTabStops?: boolean;
        /**
         * The font family
         */
        fontFamily?: string;
        /**
         * The font weight
         */
        fontWeight?: string;
        /**
         * The font size
         */
        fontSize?: number;
        /**
         * The line height
         */
        lineHeight?: number;
        /**
         * The letter spacing
         */
        letterSpacing?: number;
        /**
         * Controls fading out of unused variables.
         */
        showUnused?: boolean;
        /**
         * Controls whether to focus the inline editor in the peek widget by default.
         * Defaults to false.
         */
        peekWidgetDefaultFocus?: &#x27;tree&#x27; | &#x27;editor&#x27;;
        /**
         * Controls whether the definition link opens element in the peek widget.
         * Defaults to false.
         */
        definitionLinkOpensInPeek?: boolean;
        /**
         * Controls strikethrough deprecated variables.
         */
        showDeprecated?: boolean;
        /**
         * Control the behavior and rendering of the inline hints.
         */
        inlayHints?: IEditorInlayHintsOptions;
        /**
         * Control if the editor should use shadow DOM.
         */
        useShadowDOM?: boolean;
        /**
         * Controls the behavior of editor guides.
        */
        guides?: IGuidesOptions;
        unicodeHighlight?: IUnicodeHighlightOptions;
    }

    export interface IDiffEditorBaseOptions {
        /**
         * Allow the user to resize the diff editor split view.
         * Defaults to true.
         */
        enableSplitViewResizing?: boolean;
        /**
         * Render the differences in two side-by-side editors.
         * Defaults to true.
         */
        renderSideBySide?: boolean;
        /**
         * Timeout in milliseconds after which diff computation is cancelled.
         * Defaults to 5000.
         */
        maxComputationTime?: number;
        /**
         * Maximum supported file size in MB.
         * Defaults to 50.
         */
        maxFileSize?: number;
        /**
         * Compute the diff by ignoring leading/trailing whitespace
         * Defaults to true.
         */
        ignoreTrimWhitespace?: boolean;
        /**
         * Render +/- indicators for added/deleted changes.
         * Defaults to true.
         */
        renderIndicators?: boolean;
        /**
         * Original model should be editable?
         * Defaults to false.
         */
        originalEditable?: boolean;
        /**
         * Should the diff editor enable code lens?
         * Defaults to false.
         */
        diffCodeLens?: boolean;
        /**
         * Is the diff editor should render overview ruler
         * Defaults to true
         */
        renderOverviewRuler?: boolean;
        /**
         * Control the wrapping of the diff editor.
         */
        diffWordWrap?: &#x27;off&#x27; | &#x27;on&#x27; | &#x27;inherit&#x27;;
    }

    /**
     * Configuration options for the diff editor.
     */
    export interface IDiffEditorOptions extends IEditorOptions, IDiffEditorBaseOptions {
    }

    /**
     * An event describing that the configuration of the editor has changed.
     */
    export class ConfigurationChangedEvent {
        hasChanged(id: EditorOption): boolean;
    }

    /**
     * All computed editor options.
     */
    export interface IComputedEditorOptions {
        get&lt;T extends EditorOption&gt;(id: T): FindComputedEditorOptionValueById&lt;T&gt;;
    }

    export interface IEditorOption&lt;K1 extends EditorOption, V&gt; {
        readonly id: K1;
        readonly name: string;
        defaultValue: V;
        /**
         * Might modify &#x60;value&#x60;.
        */
        applyUpdate(value: V, update: V): ApplyUpdateResult&lt;V&gt;;
    }

    export class ApplyUpdateResult&lt;T&gt; {
        readonly newValue: T;
        readonly didChange: boolean;
        constructor(newValue: T, didChange: boolean);
    }

    /**
     * Configuration options for editor comments
     */
    export interface IEditorCommentsOptions {
        /**
         * Insert a space after the line comment token and inside the block comments tokens.
         * Defaults to true.
         */
        insertSpace?: boolean;
        /**
         * Ignore empty lines when inserting line comments.
         * Defaults to true.
         */
        ignoreEmptyLines?: boolean;
    }

    /**
     * The kind of animation in which the editor&#x27;s cursor should be rendered.
     */
    export enum TextEditorCursorBlinkingStyle {
        /**
         * Hidden
         */
        Hidden &#x3D; 0,
        /**
         * Blinking
         */
        Blink &#x3D; 1,
        /**
         * Blinking with smooth fading
         */
        Smooth &#x3D; 2,
        /**
         * Blinking with prolonged filled state and smooth fading
         */
        Phase &#x3D; 3,
        /**
         * Expand collapse animation on the y axis
         */
        Expand &#x3D; 4,
        /**
         * No-Blinking
         */
        Solid &#x3D; 5
    }

    /**
     * The style in which the editor&#x27;s cursor should be rendered.
     */
    export enum TextEditorCursorStyle {
        /**
         * As a vertical line (sitting between two characters).
         */
        Line &#x3D; 1,
        /**
         * As a block (sitting on top of a character).
         */
        Block &#x3D; 2,
        /**
         * As a horizontal line (sitting under a character).
         */
        Underline &#x3D; 3,
        /**
         * As a thin vertical line (sitting between two characters).
         */
        LineThin &#x3D; 4,
        /**
         * As an outlined block (sitting on top of a character).
         */
        BlockOutline &#x3D; 5,
        /**
         * As a thin horizontal line (sitting under a character).
         */
        UnderlineThin &#x3D; 6
    }

    /**
     * Configuration options for editor find widget
     */
    export interface IEditorFindOptions {
        /**
        * Controls whether the cursor should move to find matches while typing.
        */
        cursorMoveOnType?: boolean;
        /**
         * Controls if we seed search string in the Find Widget with editor selection.
         */
        seedSearchStringFromSelection?: &#x27;never&#x27; | &#x27;always&#x27; | &#x27;selection&#x27;;
        /**
         * Controls if Find in Selection flag is turned on in the editor.
         */
        autoFindInSelection?: &#x27;never&#x27; | &#x27;always&#x27; | &#x27;multiline&#x27;;
        addExtraSpaceOnTop?: boolean;
        /**
         * Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found
         */
        loop?: boolean;
    }

    export type GoToLocationValues &#x3D; &#x27;peek&#x27; | &#x27;gotoAndPeek&#x27; | &#x27;goto&#x27;;

    /**
     * Configuration options for go to location
     */
    export interface IGotoLocationOptions {
        multiple?: GoToLocationValues;
        multipleDefinitions?: GoToLocationValues;
        multipleTypeDefinitions?: GoToLocationValues;
        multipleDeclarations?: GoToLocationValues;
        multipleImplementations?: GoToLocationValues;
        multipleReferences?: GoToLocationValues;
        alternativeDefinitionCommand?: string;
        alternativeTypeDefinitionCommand?: string;
        alternativeDeclarationCommand?: string;
        alternativeImplementationCommand?: string;
        alternativeReferenceCommand?: string;
    }

    /**
     * Configuration options for editor hover
     */
    export interface IEditorHoverOptions {
        /**
         * Enable the hover.
         * Defaults to true.
         */
        enabled?: boolean;
        /**
         * Delay for showing the hover.
         * Defaults to 300.
         */
        delay?: number;
        /**
         * Is the hover sticky such that it can be clicked and its contents selected?
         * Defaults to true.
         */
        sticky?: boolean;
        /**
         * Should the hover be shown above the line if possible?
         * Defaults to false.
         */
        above?: boolean;
    }

    /**
     * A description for the overview ruler position.
     */
    export interface OverviewRulerPosition {
        /**
         * Width of the overview ruler
         */
        readonly width: number;
        /**
         * Height of the overview ruler
         */
        readonly height: number;
        /**
         * Top position for the overview ruler
         */
        readonly top: number;
        /**
         * Right position for the overview ruler
         */
        readonly right: number;
    }

    export enum RenderMinimap {
        None &#x3D; 0,
        Text &#x3D; 1,
        Blocks &#x3D; 2
    }

    /**
     * The internal layout details of the editor.
     */
    export interface EditorLayoutInfo {
        /**
         * Full editor width.
         */
        readonly width: number;
        /**
         * Full editor height.
         */
        readonly height: number;
        /**
         * Left position for the glyph margin.
         */
        readonly glyphMarginLeft: number;
        /**
         * The width of the glyph margin.
         */
        readonly glyphMarginWidth: number;
        /**
         * Left position for the line numbers.
         */
        readonly lineNumbersLeft: number;
        /**
         * The width of the line numbers.
         */
        readonly lineNumbersWidth: number;
        /**
         * Left position for the line decorations.
         */
        readonly decorationsLeft: number;
        /**
         * The width of the line decorations.
         */
        readonly decorationsWidth: number;
        /**
         * Left position for the content (actual text)
         */
        readonly contentLeft: number;
        /**
         * The width of the content (actual text)
         */
        readonly contentWidth: number;
        /**
         * Layout information for the minimap
         */
        readonly minimap: EditorMinimapLayoutInfo;
        /**
         * The number of columns (of typical characters) fitting on a viewport line.
         */
        readonly viewportColumn: number;
        readonly isWordWrapMinified: boolean;
        readonly isViewportWrapping: boolean;
        readonly wrappingColumn: number;
        /**
         * The width of the vertical scrollbar.
         */
        readonly verticalScrollbarWidth: number;
        /**
         * The height of the horizontal scrollbar.
         */
        readonly horizontalScrollbarHeight: number;
        /**
         * The position of the overview ruler.
         */
        readonly overviewRuler: OverviewRulerPosition;
    }

    /**
     * The internal layout details of the editor.
     */
    export interface EditorMinimapLayoutInfo {
        readonly renderMinimap: RenderMinimap;
        readonly minimapLeft: number;
        readonly minimapWidth: number;
        readonly minimapHeightIsEditorHeight: boolean;
        readonly minimapIsSampling: boolean;
        readonly minimapScale: number;
        readonly minimapLineHeight: number;
        readonly minimapCanvasInnerWidth: number;
        readonly minimapCanvasInnerHeight: number;
        readonly minimapCanvasOuterWidth: number;
        readonly minimapCanvasOuterHeight: number;
    }

    /**
     * Configuration options for editor lightbulb
     */
    export interface IEditorLightbulbOptions {
        /**
         * Enable the lightbulb code action.
         * Defaults to true.
         */
        enabled?: boolean;
    }

    /**
     * Configuration options for editor inlayHints
     */
    export interface IEditorInlayHintsOptions {
        /**
         * Enable the inline hints.
         * Defaults to true.
         */
        enabled?: boolean;
        /**
         * Font size of inline hints.
         * Default to 90% of the editor font size.
         */
        fontSize?: number;
        /**
         * Font family of inline hints.
         * Defaults to editor font family.
         */
        fontFamily?: string;
    }

    /**
     * Configuration options for editor minimap
     */
    export interface IEditorMinimapOptions {
        /**
         * Enable the rendering of the minimap.
         * Defaults to true.
         */
        enabled?: boolean;
        /**
         * Control the side of the minimap in editor.
         * Defaults to &#x27;right&#x27;.
         */
        side?: &#x27;right&#x27; | &#x27;left&#x27;;
        /**
         * Control the minimap rendering mode.
         * Defaults to &#x27;actual&#x27;.
         */
        size?: &#x27;proportional&#x27; | &#x27;fill&#x27; | &#x27;fit&#x27;;
        /**
         * Control the rendering of the minimap slider.
         * Defaults to &#x27;mouseover&#x27;.
         */
        showSlider?: &#x27;always&#x27; | &#x27;mouseover&#x27;;
        /**
         * Render the actual text on a line (as opposed to color blocks).
         * Defaults to true.
         */
        renderCharacters?: boolean;
        /**
         * Limit the width of the minimap to render at most a certain number of columns.
         * Defaults to 120.
         */
        maxColumn?: number;
        /**
         * Relative size of the font in the minimap. Defaults to 1.
         */
        scale?: number;
    }

    /**
     * Configuration options for editor padding
     */
    export interface IEditorPaddingOptions {
        /**
         * Spacing between top edge of editor and first line.
         */
        top?: number;
        /**
         * Spacing between bottom edge of editor and last line.
         */
        bottom?: number;
    }

    /**
     * Configuration options for parameter hints
     */
    export interface IEditorParameterHintOptions {
        /**
         * Enable parameter hints.
         * Defaults to true.
         */
        enabled?: boolean;
        /**
         * Enable cycling of parameter hints.
         * Defaults to false.
         */
        cycle?: boolean;
    }

    /**
     * Configuration options for quick suggestions
     */
    export interface IQuickSuggestionsOptions {
        other?: boolean;
        comments?: boolean;
        strings?: boolean;
    }

    export type LineNumbersType &#x3D; &#x27;on&#x27; | &#x27;off&#x27; | &#x27;relative&#x27; | &#x27;interval&#x27; | ((lineNumber: number) &#x3D;&gt; string);

    export enum RenderLineNumbersType {
        Off &#x3D; 0,
        On &#x3D; 1,
        Relative &#x3D; 2,
        Interval &#x3D; 3,
        Custom &#x3D; 4
    }

    export interface InternalEditorRenderLineNumbersOptions {
        readonly renderType: RenderLineNumbersType;
        readonly renderFn: ((lineNumber: number) &#x3D;&gt; string) | null;
    }

    export interface IRulerOption {
        readonly column: number;
        readonly color: string | null;
    }

    /**
     * Configuration options for editor scrollbars
     */
    export interface IEditorScrollbarOptions {
        /**
         * The size of arrows (if displayed).
         * Defaults to 11.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        arrowSize?: number;
        /**
         * Render vertical scrollbar.
         * Defaults to &#x27;auto&#x27;.
         */
        vertical?: &#x27;auto&#x27; | &#x27;visible&#x27; | &#x27;hidden&#x27;;
        /**
         * Render horizontal scrollbar.
         * Defaults to &#x27;auto&#x27;.
         */
        horizontal?: &#x27;auto&#x27; | &#x27;visible&#x27; | &#x27;hidden&#x27;;
        /**
         * Cast horizontal and vertical shadows when the content is scrolled.
         * Defaults to true.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        useShadows?: boolean;
        /**
         * Render arrows at the top and bottom of the vertical scrollbar.
         * Defaults to false.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        verticalHasArrows?: boolean;
        /**
         * Render arrows at the left and right of the horizontal scrollbar.
         * Defaults to false.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        horizontalHasArrows?: boolean;
        /**
         * Listen to mouse wheel events and react to them by scrolling.
         * Defaults to true.
         */
        handleMouseWheel?: boolean;
        /**
         * Always consume mouse wheel events (always call preventDefault() and stopPropagation() on the browser events).
         * Defaults to true.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        alwaysConsumeMouseWheel?: boolean;
        /**
         * Height in pixels for the horizontal scrollbar.
         * Defaults to 10 (px).
         */
        horizontalScrollbarSize?: number;
        /**
         * Width in pixels for the vertical scrollbar.
         * Defaults to 10 (px).
         */
        verticalScrollbarSize?: number;
        /**
         * Width in pixels for the vertical slider.
         * Defaults to &#x60;verticalScrollbarSize&#x60;.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        verticalSliderSize?: number;
        /**
         * Height in pixels for the horizontal slider.
         * Defaults to &#x60;horizontalScrollbarSize&#x60;.
         * **NOTE**: This option cannot be updated using &#x60;updateOptions()&#x60;
         */
        horizontalSliderSize?: number;
        /**
         * Scroll gutter clicks move by page vs jump to position.
         * Defaults to false.
         */
        scrollByPage?: boolean;
    }

    export interface InternalEditorScrollbarOptions {
        readonly arrowSize: number;
        readonly vertical: ScrollbarVisibility;
        readonly horizontal: ScrollbarVisibility;
        readonly useShadows: boolean;
        readonly verticalHasArrows: boolean;
        readonly horizontalHasArrows: boolean;
        readonly handleMouseWheel: boolean;
        readonly alwaysConsumeMouseWheel: boolean;
        readonly horizontalScrollbarSize: number;
        readonly horizontalSliderSize: number;
        readonly verticalScrollbarSize: number;
        readonly verticalSliderSize: number;
        readonly scrollByPage: boolean;
    }

    export type InUntrustedWorkspace &#x3D; &#x27;inUntrustedWorkspace&#x27;;

    /**
     * Configuration options for unicode highlighting.
     */
    export interface IUnicodeHighlightOptions {
        nonBasicASCII?: boolean | InUntrustedWorkspace;
        invisibleCharacters?: boolean;
        ambiguousCharacters?: boolean;
        includeComments?: boolean | InUntrustedWorkspace;
        /**
         * A map of allowed characters (true: allowed).
        */
        allowedCharacters?: Record&lt;string, true&gt;;
    }

    export interface IInlineSuggestOptions {
        /**
         * Enable or disable the rendering of automatic inline completions.
        */
        enabled?: boolean;
        /**
         * Configures the mode.
         * Use &#x60;prefix&#x60; to only show ghost text if the text to replace is a prefix of the suggestion text.
         * Use &#x60;subword&#x60; to only show ghost text if the replace text is a subword of the suggestion text.
         * Use &#x60;subwordSmart&#x60; to only show ghost text if the replace text is a subword of the suggestion text, but the subword must start after the cursor position.
         * Defaults to &#x60;prefix&#x60;.
        */
        mode?: &#x27;prefix&#x27; | &#x27;subword&#x27; | &#x27;subwordSmart&#x27;;
    }

    export interface IBracketPairColorizationOptions {
        /**
         * Enable or disable bracket pair colorization.
        */
        enabled?: boolean;
    }

    export interface IGuidesOptions {
        /**
         * Enable rendering of bracket pair guides.
         * Defaults to false.
        */
        bracketPairs?: boolean | &#x27;active&#x27;;
        /**
         * Enable rendering of vertical bracket pair guides.
         * Defaults to &#x27;active&#x27;.
         */
        bracketPairsHorizontal?: boolean | &#x27;active&#x27;;
        /**
         * Enable highlighting of the active bracket pair.
         * Defaults to true.
        */
        highlightActiveBracketPair?: boolean;
        /**
         * Enable rendering of indent guides.
         * Defaults to true.
         */
        indentation?: boolean;
        /**
         * Enable highlighting of the active indent guide.
         * Defaults to true.
         */
        highlightActiveIndentation?: boolean;
    }

    /**
     * Configuration options for editor suggest widget
     */
    export interface ISuggestOptions {
        /**
         * Overwrite word ends on accept. Default to false.
         */
        insertMode?: &#x27;insert&#x27; | &#x27;replace&#x27;;
        /**
         * Enable graceful matching. Defaults to true.
         */
        filterGraceful?: boolean;
        /**
         * Prevent quick suggestions when a snippet is active. Defaults to true.
         */
        snippetsPreventQuickSuggestions?: boolean;
        /**
         * Favors words that appear close to the cursor.
         */
        localityBonus?: boolean;
        /**
         * Enable using global storage for remembering suggestions.
         */
        shareSuggestSelections?: boolean;
        /**
         * Enable or disable icons in suggestions. Defaults to true.
         */
        showIcons?: boolean;
        /**
         * Enable or disable the suggest status bar.
         */
        showStatusBar?: boolean;
        /**
         * Enable or disable the rendering of the suggestion preview.
         */
        preview?: boolean;
        /**
         * Configures the mode of the preview.
        */
        previewMode?: &#x27;prefix&#x27; | &#x27;subword&#x27; | &#x27;subwordSmart&#x27;;
        /**
         * Show details inline with the label. Defaults to true.
         */
        showInlineDetails?: boolean;
        /**
         * Show method-suggestions.
         */
        showMethods?: boolean;
        /**
         * Show function-suggestions.
         */
        showFunctions?: boolean;
        /**
         * Show constructor-suggestions.
         */
        showConstructors?: boolean;
        /**
         * Show deprecated-suggestions.
         */
        showDeprecated?: boolean;
        /**
         * Show field-suggestions.
         */
        showFields?: boolean;
        /**
         * Show variable-suggestions.
         */
        showVariables?: boolean;
        /**
         * Show class-suggestions.
         */
        showClasses?: boolean;
        /**
         * Show struct-suggestions.
         */
        showStructs?: boolean;
        /**
         * Show interface-suggestions.
         */
        showInterfaces?: boolean;
        /**
         * Show module-suggestions.
         */
        showModules?: boolean;
        /**
         * Show property-suggestions.
         */
        showProperties?: boolean;
        /**
         * Show event-suggestions.
         */
        showEvents?: boolean;
        /**
         * Show operator-suggestions.
         */
        showOperators?: boolean;
        /**
         * Show unit-suggestions.
         */
        showUnits?: boolean;
        /**
         * Show value-suggestions.
         */
        showValues?: boolean;
        /**
         * Show constant-suggestions.
         */
        showConstants?: boolean;
        /**
         * Show enum-suggestions.
         */
        showEnums?: boolean;
        /**
         * Show enumMember-suggestions.
         */
        showEnumMembers?: boolean;
        /**
         * Show keyword-suggestions.
         */
        showKeywords?: boolean;
        /**
         * Show text-suggestions.
         */
        showWords?: boolean;
        /**
         * Show color-suggestions.
         */
        showColors?: boolean;
        /**
         * Show file-suggestions.
         */
        showFiles?: boolean;
        /**
         * Show reference-suggestions.
         */
        showReferences?: boolean;
        /**
         * Show folder-suggestions.
         */
        showFolders?: boolean;
        /**
         * Show typeParameter-suggestions.
         */
        showTypeParameters?: boolean;
        /**
         * Show issue-suggestions.
         */
        showIssues?: boolean;
        /**
         * Show user-suggestions.
         */
        showUsers?: boolean;
        /**
         * Show snippet-suggestions.
         */
        showSnippets?: boolean;
    }

    export interface ISmartSelectOptions {
        selectLeadingAndTrailingWhitespace?: boolean;
    }

    /**
     * Describes how to indent wrapped lines.
     */
    export enum WrappingIndent {
        /**
         * No indentation &#x3D;&gt; wrapped lines begin at column 1.
         */
        None &#x3D; 0,
        /**
         * Same &#x3D;&gt; wrapped lines get the same indentation as the parent.
         */
        Same &#x3D; 1,
        /**
         * Indent &#x3D;&gt; wrapped lines get +1 indentation toward the parent.
         */
        Indent &#x3D; 2,
        /**
         * DeepIndent &#x3D;&gt; wrapped lines get +2 indentation toward the parent.
         */
        DeepIndent &#x3D; 3
    }

    export interface EditorWrappingInfo {
        readonly isDominatedByLongLines: boolean;
        readonly isWordWrapMinified: boolean;
        readonly isViewportWrapping: boolean;
        readonly wrappingColumn: number;
    }

    export enum EditorOption {
        acceptSuggestionOnCommitCharacter &#x3D; 0,
        acceptSuggestionOnEnter &#x3D; 1,
        accessibilitySupport &#x3D; 2,
        accessibilityPageSize &#x3D; 3,
        ariaLabel &#x3D; 4,
        autoClosingBrackets &#x3D; 5,
        autoClosingDelete &#x3D; 6,
        autoClosingOvertype &#x3D; 7,
        autoClosingQuotes &#x3D; 8,
        autoIndent &#x3D; 9,
        automaticLayout &#x3D; 10,
        autoSurround &#x3D; 11,
        bracketPairColorization &#x3D; 12,
        guides &#x3D; 13,
        codeLens &#x3D; 14,
        codeLensFontFamily &#x3D; 15,
        codeLensFontSize &#x3D; 16,
        colorDecorators &#x3D; 17,
        columnSelection &#x3D; 18,
        comments &#x3D; 19,
        contextmenu &#x3D; 20,
        copyWithSyntaxHighlighting &#x3D; 21,
        cursorBlinking &#x3D; 22,
        cursorSmoothCaretAnimation &#x3D; 23,
        cursorStyle &#x3D; 24,
        cursorSurroundingLines &#x3D; 25,
        cursorSurroundingLinesStyle &#x3D; 26,
        cursorWidth &#x3D; 27,
        disableLayerHinting &#x3D; 28,
        disableMonospaceOptimizations &#x3D; 29,
        domReadOnly &#x3D; 30,
        dragAndDrop &#x3D; 31,
        emptySelectionClipboard &#x3D; 32,
        extraEditorClassName &#x3D; 33,
        fastScrollSensitivity &#x3D; 34,
        find &#x3D; 35,
        fixedOverflowWidgets &#x3D; 36,
        folding &#x3D; 37,
        foldingStrategy &#x3D; 38,
        foldingHighlight &#x3D; 39,
        foldingImportsByDefault &#x3D; 40,
        unfoldOnClickAfterEndOfLine &#x3D; 41,
        fontFamily &#x3D; 42,
        fontInfo &#x3D; 43,
        fontLigatures &#x3D; 44,
        fontSize &#x3D; 45,
        fontWeight &#x3D; 46,
        formatOnPaste &#x3D; 47,
        formatOnType &#x3D; 48,
        glyphMargin &#x3D; 49,
        gotoLocation &#x3D; 50,
        hideCursorInOverviewRuler &#x3D; 51,
        hover &#x3D; 52,
        inDiffEditor &#x3D; 53,
        inlineSuggest &#x3D; 54,
        letterSpacing &#x3D; 55,
        lightbulb &#x3D; 56,
        lineDecorationsWidth &#x3D; 57,
        lineHeight &#x3D; 58,
        lineNumbers &#x3D; 59,
        lineNumbersMinChars &#x3D; 60,
        linkedEditing &#x3D; 61,
        links &#x3D; 62,
        matchBrackets &#x3D; 63,
        minimap &#x3D; 64,
        mouseStyle &#x3D; 65,
        mouseWheelScrollSensitivity &#x3D; 66,
        mouseWheelZoom &#x3D; 67,
        multiCursorMergeOverlapping &#x3D; 68,
        multiCursorModifier &#x3D; 69,
        multiCursorPaste &#x3D; 70,
        occurrencesHighlight &#x3D; 71,
        overviewRulerBorder &#x3D; 72,
        overviewRulerLanes &#x3D; 73,
        padding &#x3D; 74,
        parameterHints &#x3D; 75,
        peekWidgetDefaultFocus &#x3D; 76,
        definitionLinkOpensInPeek &#x3D; 77,
        quickSuggestions &#x3D; 78,
        quickSuggestionsDelay &#x3D; 79,
        readOnly &#x3D; 80,
        renameOnType &#x3D; 81,
        renderControlCharacters &#x3D; 82,
        renderFinalNewline &#x3D; 83,
        renderLineHighlight &#x3D; 84,
        renderLineHighlightOnlyWhenFocus &#x3D; 85,
        renderValidationDecorations &#x3D; 86,
        renderWhitespace &#x3D; 87,
        revealHorizontalRightPadding &#x3D; 88,
        roundedSelection &#x3D; 89,
        rulers &#x3D; 90,
        scrollbar &#x3D; 91,
        scrollBeyondLastColumn &#x3D; 92,
        scrollBeyondLastLine &#x3D; 93,
        scrollPredominantAxis &#x3D; 94,
        selectionClipboard &#x3D; 95,
        selectionHighlight &#x3D; 96,
        selectOnLineNumbers &#x3D; 97,
        showFoldingControls &#x3D; 98,
        showUnused &#x3D; 99,
        snippetSuggestions &#x3D; 100,
        smartSelect &#x3D; 101,
        smoothScrolling &#x3D; 102,
        stickyTabStops &#x3D; 103,
        stopRenderingLineAfter &#x3D; 104,
        suggest &#x3D; 105,
        suggestFontSize &#x3D; 106,
        suggestLineHeight &#x3D; 107,
        suggestOnTriggerCharacters &#x3D; 108,
        suggestSelection &#x3D; 109,
        tabCompletion &#x3D; 110,
        tabIndex &#x3D; 111,
        unicodeHighlighting &#x3D; 112,
        unusualLineTerminators &#x3D; 113,
        useShadowDOM &#x3D; 114,
        useTabStops &#x3D; 115,
        wordSeparators &#x3D; 116,
        wordWrap &#x3D; 117,
        wordWrapBreakAfterCharacters &#x3D; 118,
        wordWrapBreakBeforeCharacters &#x3D; 119,
        wordWrapColumn &#x3D; 120,
        wordWrapOverride1 &#x3D; 121,
        wordWrapOverride2 &#x3D; 122,
        wrappingIndent &#x3D; 123,
        wrappingStrategy &#x3D; 124,
        showDeprecated &#x3D; 125,
        inlayHints &#x3D; 126,
        editorClassName &#x3D; 127,
        pixelRatio &#x3D; 128,
        tabFocusMode &#x3D; 129,
        layoutInfo &#x3D; 130,
        wrappingInfo &#x3D; 131
    }

    export const EditorOptions: {
        acceptSuggestionOnCommitCharacter: IEditorOption&lt;EditorOption.acceptSuggestionOnCommitCharacter, boolean&gt;;
        acceptSuggestionOnEnter: IEditorOption&lt;EditorOption.acceptSuggestionOnEnter, &#x27;on&#x27; | &#x27;off&#x27; | &#x27;smart&#x27;&gt;;
        accessibilitySupport: IEditorOption&lt;EditorOption.accessibilitySupport, AccessibilitySupport&gt;;
        accessibilityPageSize: IEditorOption&lt;EditorOption.accessibilityPageSize, number&gt;;
        ariaLabel: IEditorOption&lt;EditorOption.ariaLabel, string&gt;;
        autoClosingBrackets: IEditorOption&lt;EditorOption.autoClosingBrackets, &#x27;always&#x27; | &#x27;languageDefined&#x27; | &#x27;beforeWhitespace&#x27; | &#x27;never&#x27;&gt;;
        autoClosingDelete: IEditorOption&lt;EditorOption.autoClosingDelete, &#x27;always&#x27; | &#x27;never&#x27; | &#x27;auto&#x27;&gt;;
        autoClosingOvertype: IEditorOption&lt;EditorOption.autoClosingOvertype, &#x27;always&#x27; | &#x27;never&#x27; | &#x27;auto&#x27;&gt;;
        autoClosingQuotes: IEditorOption&lt;EditorOption.autoClosingQuotes, &#x27;always&#x27; | &#x27;languageDefined&#x27; | &#x27;beforeWhitespace&#x27; | &#x27;never&#x27;&gt;;
        autoIndent: IEditorOption&lt;EditorOption.autoIndent, EditorAutoIndentStrategy&gt;;
        automaticLayout: IEditorOption&lt;EditorOption.automaticLayout, boolean&gt;;
        autoSurround: IEditorOption&lt;EditorOption.autoSurround, &#x27;languageDefined&#x27; | &#x27;never&#x27; | &#x27;quotes&#x27; | &#x27;brackets&#x27;&gt;;
        bracketPairColorization: IEditorOption&lt;EditorOption.bracketPairColorization, Readonly&lt;Required&lt;IBracketPairColorizationOptions&gt;&gt;&gt;;
        bracketPairGuides: IEditorOption&lt;EditorOption.guides, Readonly&lt;Required&lt;IGuidesOptions&gt;&gt;&gt;;
        stickyTabStops: IEditorOption&lt;EditorOption.stickyTabStops, boolean&gt;;
        codeLens: IEditorOption&lt;EditorOption.codeLens, boolean&gt;;
        codeLensFontFamily: IEditorOption&lt;EditorOption.codeLensFontFamily, string&gt;;
        codeLensFontSize: IEditorOption&lt;EditorOption.codeLensFontSize, number&gt;;
        colorDecorators: IEditorOption&lt;EditorOption.colorDecorators, boolean&gt;;
        columnSelection: IEditorOption&lt;EditorOption.columnSelection, boolean&gt;;
        comments: IEditorOption&lt;EditorOption.comments, Readonly&lt;Required&lt;IEditorCommentsOptions&gt;&gt;&gt;;
        contextmenu: IEditorOption&lt;EditorOption.contextmenu, boolean&gt;;
        copyWithSyntaxHighlighting: IEditorOption&lt;EditorOption.copyWithSyntaxHighlighting, boolean&gt;;
        cursorBlinking: IEditorOption&lt;EditorOption.cursorBlinking, TextEditorCursorBlinkingStyle&gt;;
        cursorSmoothCaretAnimation: IEditorOption&lt;EditorOption.cursorSmoothCaretAnimation, boolean&gt;;
        cursorStyle: IEditorOption&lt;EditorOption.cursorStyle, TextEditorCursorStyle&gt;;
        cursorSurroundingLines: IEditorOption&lt;EditorOption.cursorSurroundingLines, number&gt;;
        cursorSurroundingLinesStyle: IEditorOption&lt;EditorOption.cursorSurroundingLinesStyle, &#x27;default&#x27; | &#x27;all&#x27;&gt;;
        cursorWidth: IEditorOption&lt;EditorOption.cursorWidth, number&gt;;
        disableLayerHinting: IEditorOption&lt;EditorOption.disableLayerHinting, boolean&gt;;
        disableMonospaceOptimizations: IEditorOption&lt;EditorOption.disableMonospaceOptimizations, boolean&gt;;
        domReadOnly: IEditorOption&lt;EditorOption.domReadOnly, boolean&gt;;
        dragAndDrop: IEditorOption&lt;EditorOption.dragAndDrop, boolean&gt;;
        emptySelectionClipboard: IEditorOption&lt;EditorOption.emptySelectionClipboard, boolean&gt;;
        extraEditorClassName: IEditorOption&lt;EditorOption.extraEditorClassName, string&gt;;
        fastScrollSensitivity: IEditorOption&lt;EditorOption.fastScrollSensitivity, number&gt;;
        find: IEditorOption&lt;EditorOption.find, Readonly&lt;Required&lt;IEditorFindOptions&gt;&gt;&gt;;
        fixedOverflowWidgets: IEditorOption&lt;EditorOption.fixedOverflowWidgets, boolean&gt;;
        folding: IEditorOption&lt;EditorOption.folding, boolean&gt;;
        foldingStrategy: IEditorOption&lt;EditorOption.foldingStrategy, &#x27;auto&#x27; | &#x27;indentation&#x27;&gt;;
        foldingHighlight: IEditorOption&lt;EditorOption.foldingHighlight, boolean&gt;;
        foldingImportsByDefault: IEditorOption&lt;EditorOption.foldingImportsByDefault, boolean&gt;;
        unfoldOnClickAfterEndOfLine: IEditorOption&lt;EditorOption.unfoldOnClickAfterEndOfLine, boolean&gt;;
        fontFamily: IEditorOption&lt;EditorOption.fontFamily, string&gt;;
        fontInfo: IEditorOption&lt;EditorOption.fontInfo, FontInfo&gt;;
        fontLigatures2: IEditorOption&lt;EditorOption.fontLigatures, string&gt;;
        fontSize: IEditorOption&lt;EditorOption.fontSize, number&gt;;
        fontWeight: IEditorOption&lt;EditorOption.fontWeight, string&gt;;
        formatOnPaste: IEditorOption&lt;EditorOption.formatOnPaste, boolean&gt;;
        formatOnType: IEditorOption&lt;EditorOption.formatOnType, boolean&gt;;
        glyphMargin: IEditorOption&lt;EditorOption.glyphMargin, boolean&gt;;
        gotoLocation: IEditorOption&lt;EditorOption.gotoLocation, Readonly&lt;Required&lt;IGotoLocationOptions&gt;&gt;&gt;;
        hideCursorInOverviewRuler: IEditorOption&lt;EditorOption.hideCursorInOverviewRuler, boolean&gt;;
        hover: IEditorOption&lt;EditorOption.hover, Readonly&lt;Required&lt;IEditorHoverOptions&gt;&gt;&gt;;
        inDiffEditor: IEditorOption&lt;EditorOption.inDiffEditor, boolean&gt;;
        letterSpacing: IEditorOption&lt;EditorOption.letterSpacing, number&gt;;
        lightbulb: IEditorOption&lt;EditorOption.lightbulb, Readonly&lt;Required&lt;IEditorLightbulbOptions&gt;&gt;&gt;;
        lineDecorationsWidth: IEditorOption&lt;EditorOption.lineDecorationsWidth, string | number&gt;;
        lineHeight: IEditorOption&lt;EditorOption.lineHeight, number&gt;;
        lineNumbers: IEditorOption&lt;EditorOption.lineNumbers, InternalEditorRenderLineNumbersOptions&gt;;
        lineNumbersMinChars: IEditorOption&lt;EditorOption.lineNumbersMinChars, number&gt;;
        linkedEditing: IEditorOption&lt;EditorOption.linkedEditing, boolean&gt;;
        links: IEditorOption&lt;EditorOption.links, boolean&gt;;
        matchBrackets: IEditorOption&lt;EditorOption.matchBrackets, &#x27;always&#x27; | &#x27;never&#x27; | &#x27;near&#x27;&gt;;
        minimap: IEditorOption&lt;EditorOption.minimap, Readonly&lt;Required&lt;IEditorMinimapOptions&gt;&gt;&gt;;
        mouseStyle: IEditorOption&lt;EditorOption.mouseStyle, &#x27;default&#x27; | &#x27;text&#x27; | &#x27;copy&#x27;&gt;;
        mouseWheelScrollSensitivity: IEditorOption&lt;EditorOption.mouseWheelScrollSensitivity, number&gt;;
        mouseWheelZoom: IEditorOption&lt;EditorOption.mouseWheelZoom, boolean&gt;;
        multiCursorMergeOverlapping: IEditorOption&lt;EditorOption.multiCursorMergeOverlapping, boolean&gt;;
        multiCursorModifier: IEditorOption&lt;EditorOption.multiCursorModifier, &#x27;altKey&#x27; | &#x27;metaKey&#x27; | &#x27;ctrlKey&#x27;&gt;;
        multiCursorPaste: IEditorOption&lt;EditorOption.multiCursorPaste, &#x27;spread&#x27; | &#x27;full&#x27;&gt;;
        occurrencesHighlight: IEditorOption&lt;EditorOption.occurrencesHighlight, boolean&gt;;
        overviewRulerBorder: IEditorOption&lt;EditorOption.overviewRulerBorder, boolean&gt;;
        overviewRulerLanes: IEditorOption&lt;EditorOption.overviewRulerLanes, number&gt;;
        padding: IEditorOption&lt;EditorOption.padding, Readonly&lt;Required&lt;IEditorPaddingOptions&gt;&gt;&gt;;
        parameterHints: IEditorOption&lt;EditorOption.parameterHints, Readonly&lt;Required&lt;IEditorParameterHintOptions&gt;&gt;&gt;;
        peekWidgetDefaultFocus: IEditorOption&lt;EditorOption.peekWidgetDefaultFocus, &#x27;tree&#x27; | &#x27;editor&#x27;&gt;;
        definitionLinkOpensInPeek: IEditorOption&lt;EditorOption.definitionLinkOpensInPeek, boolean&gt;;
        quickSuggestions: IEditorOption&lt;EditorOption.quickSuggestions, any&gt;;
        quickSuggestionsDelay: IEditorOption&lt;EditorOption.quickSuggestionsDelay, number&gt;;
        readOnly: IEditorOption&lt;EditorOption.readOnly, boolean&gt;;
        renameOnType: IEditorOption&lt;EditorOption.renameOnType, boolean&gt;;
        renderControlCharacters: IEditorOption&lt;EditorOption.renderControlCharacters, boolean&gt;;
        renderFinalNewline: IEditorOption&lt;EditorOption.renderFinalNewline, boolean&gt;;
        renderLineHighlight: IEditorOption&lt;EditorOption.renderLineHighlight, &#x27;all&#x27; | &#x27;line&#x27; | &#x27;none&#x27; | &#x27;gutter&#x27;&gt;;
        renderLineHighlightOnlyWhenFocus: IEditorOption&lt;EditorOption.renderLineHighlightOnlyWhenFocus, boolean&gt;;
        renderValidationDecorations: IEditorOption&lt;EditorOption.renderValidationDecorations, &#x27;on&#x27; | &#x27;off&#x27; | &#x27;editable&#x27;&gt;;
        renderWhitespace: IEditorOption&lt;EditorOption.renderWhitespace, &#x27;all&#x27; | &#x27;none&#x27; | &#x27;boundary&#x27; | &#x27;selection&#x27; | &#x27;trailing&#x27;&gt;;
        revealHorizontalRightPadding: IEditorOption&lt;EditorOption.revealHorizontalRightPadding, number&gt;;
        roundedSelection: IEditorOption&lt;EditorOption.roundedSelection, boolean&gt;;
        rulers: IEditorOption&lt;EditorOption.rulers, {}&gt;;
        scrollbar: IEditorOption&lt;EditorOption.scrollbar, InternalEditorScrollbarOptions&gt;;
        scrollBeyondLastColumn: IEditorOption&lt;EditorOption.scrollBeyondLastColumn, number&gt;;
        scrollBeyondLastLine: IEditorOption&lt;EditorOption.scrollBeyondLastLine, boolean&gt;;
        scrollPredominantAxis: IEditorOption&lt;EditorOption.scrollPredominantAxis, boolean&gt;;
        selectionClipboard: IEditorOption&lt;EditorOption.selectionClipboard, boolean&gt;;
        selectionHighlight: IEditorOption&lt;EditorOption.selectionHighlight, boolean&gt;;
        selectOnLineNumbers: IEditorOption&lt;EditorOption.selectOnLineNumbers, boolean&gt;;
        showFoldingControls: IEditorOption&lt;EditorOption.showFoldingControls, &#x27;always&#x27; | &#x27;mouseover&#x27;&gt;;
        showUnused: IEditorOption&lt;EditorOption.showUnused, boolean&gt;;
        showDeprecated: IEditorOption&lt;EditorOption.showDeprecated, boolean&gt;;
        inlayHints: IEditorOption&lt;EditorOption.inlayHints, Readonly&lt;Required&lt;IEditorInlayHintsOptions&gt;&gt;&gt;;
        snippetSuggestions: IEditorOption&lt;EditorOption.snippetSuggestions, &#x27;none&#x27; | &#x27;top&#x27; | &#x27;bottom&#x27; | &#x27;inline&#x27;&gt;;
        smartSelect: IEditorOption&lt;EditorOption.smartSelect, Readonly&lt;Required&lt;ISmartSelectOptions&gt;&gt;&gt;;
        smoothScrolling: IEditorOption&lt;EditorOption.smoothScrolling, boolean&gt;;
        stopRenderingLineAfter: IEditorOption&lt;EditorOption.stopRenderingLineAfter, number&gt;;
        suggest: IEditorOption&lt;EditorOption.suggest, Readonly&lt;Required&lt;ISuggestOptions&gt;&gt;&gt;;
        inlineSuggest: IEditorOption&lt;EditorOption.inlineSuggest, Readonly&lt;Required&lt;IInlineSuggestOptions&gt;&gt;&gt;;
        suggestFontSize: IEditorOption&lt;EditorOption.suggestFontSize, number&gt;;
        suggestLineHeight: IEditorOption&lt;EditorOption.suggestLineHeight, number&gt;;
        suggestOnTriggerCharacters: IEditorOption&lt;EditorOption.suggestOnTriggerCharacters, boolean&gt;;
        suggestSelection: IEditorOption&lt;EditorOption.suggestSelection, &#x27;first&#x27; | &#x27;recentlyUsed&#x27; | &#x27;recentlyUsedByPrefix&#x27;&gt;;
        tabCompletion: IEditorOption&lt;EditorOption.tabCompletion, &#x27;on&#x27; | &#x27;off&#x27; | &#x27;onlySnippets&#x27;&gt;;
        tabIndex: IEditorOption&lt;EditorOption.tabIndex, number&gt;;
        unicodeHighlight: IEditorOption&lt;EditorOption.unicodeHighlighting, Required&lt;Readonly&lt;IUnicodeHighlightOptions&gt;&gt;&gt;;
        unusualLineTerminators: IEditorOption&lt;EditorOption.unusualLineTerminators, &#x27;auto&#x27; | &#x27;off&#x27; | &#x27;prompt&#x27;&gt;;
        useShadowDOM: IEditorOption&lt;EditorOption.useShadowDOM, boolean&gt;;
        useTabStops: IEditorOption&lt;EditorOption.useTabStops, boolean&gt;;
        wordSeparators: IEditorOption&lt;EditorOption.wordSeparators, string&gt;;
        wordWrap: IEditorOption&lt;EditorOption.wordWrap, &#x27;on&#x27; | &#x27;off&#x27; | &#x27;wordWrapColumn&#x27; | &#x27;bounded&#x27;&gt;;
        wordWrapBreakAfterCharacters: IEditorOption&lt;EditorOption.wordWrapBreakAfterCharacters, string&gt;;
        wordWrapBreakBeforeCharacters: IEditorOption&lt;EditorOption.wordWrapBreakBeforeCharacters, string&gt;;
        wordWrapColumn: IEditorOption&lt;EditorOption.wordWrapColumn, number&gt;;
        wordWrapOverride1: IEditorOption&lt;EditorOption.wordWrapOverride1, &#x27;on&#x27; | &#x27;off&#x27; | &#x27;inherit&#x27;&gt;;
        wordWrapOverride2: IEditorOption&lt;EditorOption.wordWrapOverride2, &#x27;on&#x27; | &#x27;off&#x27; | &#x27;inherit&#x27;&gt;;
        wrappingIndent: IEditorOption&lt;EditorOption.wrappingIndent, WrappingIndent&gt;;
        wrappingStrategy: IEditorOption&lt;EditorOption.wrappingStrategy, &#x27;simple&#x27; | &#x27;advanced&#x27;&gt;;
        editorClassName: IEditorOption&lt;EditorOption.editorClassName, string&gt;;
        pixelRatio: IEditorOption&lt;EditorOption.pixelRatio, number&gt;;
        tabFocusMode: IEditorOption&lt;EditorOption.tabFocusMode, boolean&gt;;
        layoutInfo: IEditorOption&lt;EditorOption.layoutInfo, EditorLayoutInfo&gt;;
        wrappingInfo: IEditorOption&lt;EditorOption.wrappingInfo, EditorWrappingInfo&gt;;
    };

    type EditorOptionsType &#x3D; typeof EditorOptions;

    type FindEditorOptionsKeyById&lt;T extends EditorOption&gt; &#x3D; {
        [K in keyof EditorOptionsType]: EditorOptionsType[K][&#x27;id&#x27;] extends T ? K : never;
    }[keyof EditorOptionsType];

    type ComputedEditorOptionValue&lt;T extends IEditorOption&lt;any, any&gt;&gt; &#x3D; T extends IEditorOption&lt;any, infer R&gt; ? R : never;

    export type FindComputedEditorOptionValueById&lt;T extends EditorOption&gt; &#x3D; NonNullable&lt;ComputedEditorOptionValue&lt;EditorOptionsType[FindEditorOptionsKeyById&lt;T&gt;]&gt;&gt;;

    /**
     * A view zone is a full horizontal rectangle that &#x27;pushes&#x27; text down.
     * The editor reserves space for view zones when rendering.
     */
    export interface IViewZone {
        /**
         * The line number after which this zone should appear.
         * Use 0 to place a view zone before the first line number.
         */
        afterLineNumber: number;
        /**
         * The column after which this zone should appear.
         * If not set, the maxLineColumn of &#x60;afterLineNumber&#x60; will be used.
         */
        afterColumn?: number;
        /**
         * Suppress mouse down events.
         * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.
         * Defaults to false
         */
        suppressMouseDown?: boolean;
        /**
         * The height in lines of the view zone.
         * If specified, &#x60;heightInPx&#x60; will be used instead of this.
         * If neither &#x60;heightInPx&#x60; nor &#x60;heightInLines&#x60; is specified, a default of &#x60;heightInLines&#x60; &#x3D; 1 will be chosen.
         */
        heightInLines?: number;
        /**
         * The height in px of the view zone.
         * If this is set, the editor will give preference to it rather than &#x60;heightInLines&#x60; above.
         * If neither &#x60;heightInPx&#x60; nor &#x60;heightInLines&#x60; is specified, a default of &#x60;heightInLines&#x60; &#x3D; 1 will be chosen.
         */
        heightInPx?: number;
        /**
         * The minimum width in px of the view zone.
         * If this is set, the editor will ensure that the scroll width is &gt;&#x3D; than this value.
         */
        minWidthInPx?: number;
        /**
         * The dom node of the view zone
         */
        domNode: HTMLElement;
        /**
         * An optional dom node for the view zone that will be placed in the margin area.
         */
        marginDomNode?: HTMLElement | null;
        /**
         * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).
         */
        onDomNodeTop?: (top: number) &#x3D;&gt; void;
        /**
         * Callback which gives the height in pixels of the view zone.
         */
        onComputedHeight?: (height: number) &#x3D;&gt; void;
    }

    /**
     * An accessor that allows for zones to be added or removed.
     */
    export interface IViewZoneChangeAccessor {
        /**
         * Create a new view zone.
         * @param zone Zone to create
         * @return A unique identifier to the view zone.
         */
        addZone(zone: IViewZone): string;
        /**
         * Remove a zone
         * @param id A unique identifier to the view zone, as returned by the &#x60;addZone&#x60; call.
         */
        removeZone(id: string): void;
        /**
         * Change a zone&#x27;s position.
         * The editor will rescan the &#x60;afterLineNumber&#x60; and &#x60;afterColumn&#x60; properties of a view zone.
         */
        layoutZone(id: string): void;
    }

    /**
     * A positioning preference for rendering content widgets.
     */
    export enum ContentWidgetPositionPreference {
        /**
         * Place the content widget exactly at a position
         */
        EXACT &#x3D; 0,
        /**
         * Place the content widget above a position
         */
        ABOVE &#x3D; 1,
        /**
         * Place the content widget below a position
         */
        BELOW &#x3D; 2
    }

    /**
     * A position for rendering content widgets.
     */
    export interface IContentWidgetPosition {
        /**
         * Desired position for the content widget.
         * &#x60;preference&#x60; will also affect the placement.
         */
        position: IPosition | null;
        /**
         * Optionally, a range can be provided to further
         * define the position of the content widget.
         */
        range?: IRange | null;
        /**
         * Placement preference for position, in order of preference.
         */
        preference: ContentWidgetPositionPreference[];
    }

    /**
     * A content widget renders inline with the text and can be easily placed &#x27;near&#x27; an editor position.
     */
    export interface IContentWidget {
        /**
         * Render this content widget in a location where it could overflow the editor&#x27;s view dom node.
         */
        allowEditorOverflow?: boolean;
        suppressMouseDown?: boolean;
        /**
         * Get a unique identifier of the content widget.
         */
        getId(): string;
        /**
         * Get the dom node of the content widget.
         */
        getDomNode(): HTMLElement;
        /**
         * Get the placement of the content widget.
         * If null is returned, the content widget will be placed off screen.
         */
        getPosition(): IContentWidgetPosition | null;
        /**
         * Optional function that is invoked before rendering
         * the content widget. If a dimension is returned the editor will
         * attempt to use it.
         */
        beforeRender?(): IDimension | null;
        /**
         * Optional function that is invoked after rendering the content
         * widget. Is being invoked with the selected position preference
         * or &#x60;null&#x60; if not rendered.
         */
        afterRender?(position: ContentWidgetPositionPreference | null): void;
    }

    /**
     * A positioning preference for rendering overlay widgets.
     */
    export enum OverlayWidgetPositionPreference {
        /**
         * Position the overlay widget in the top right corner
         */
        TOP_RIGHT_CORNER &#x3D; 0,
        /**
         * Position the overlay widget in the bottom right corner
         */
        BOTTOM_RIGHT_CORNER &#x3D; 1,
        /**
         * Position the overlay widget in the top center
         */
        TOP_CENTER &#x3D; 2
    }

    /**
     * A position for rendering overlay widgets.
     */
    export interface IOverlayWidgetPosition {
        /**
         * The position preference for the overlay widget.
         */
        preference: OverlayWidgetPositionPreference | null;
    }

    /**
     * An overlay widgets renders on top of the text.
     */
    export interface IOverlayWidget {
        /**
         * Get a unique identifier of the overlay widget.
         */
        getId(): string;
        /**
         * Get the dom node of the overlay widget.
         */
        getDomNode(): HTMLElement;
        /**
         * Get the placement of the overlay widget.
         * If null is returned, the overlay widget is responsible to place itself.
         */
        getPosition(): IOverlayWidgetPosition | null;
    }

    /**
     * Type of hit element with the mouse in the editor.
     */
    export enum MouseTargetType {
        /**
         * Mouse is on top of an unknown element.
         */
        UNKNOWN &#x3D; 0,
        /**
         * Mouse is on top of the textarea used for input.
         */
        TEXTAREA &#x3D; 1,
        /**
         * Mouse is on top of the glyph margin
         */
        GUTTER_GLYPH_MARGIN &#x3D; 2,
        /**
         * Mouse is on top of the line numbers
         */
        GUTTER_LINE_NUMBERS &#x3D; 3,
        /**
         * Mouse is on top of the line decorations
         */
        GUTTER_LINE_DECORATIONS &#x3D; 4,
        /**
         * Mouse is on top of the whitespace left in the gutter by a view zone.
         */
        GUTTER_VIEW_ZONE &#x3D; 5,
        /**
         * Mouse is on top of text in the content.
         */
        CONTENT_TEXT &#x3D; 6,
        /**
         * Mouse is on top of empty space in the content (e.g. after line text or below last line)
         */
        CONTENT_EMPTY &#x3D; 7,
        /**
         * Mouse is on top of a view zone in the content.
         */
        CONTENT_VIEW_ZONE &#x3D; 8,
        /**
         * Mouse is on top of a content widget.
         */
        CONTENT_WIDGET &#x3D; 9,
        /**
         * Mouse is on top of the decorations overview ruler.
         */
        OVERVIEW_RULER &#x3D; 10,
        /**
         * Mouse is on top of a scrollbar.
         */
        SCROLLBAR &#x3D; 11,
        /**
         * Mouse is on top of an overlay widget.
         */
        OVERLAY_WIDGET &#x3D; 12,
        /**
         * Mouse is outside of the editor.
         */
        OUTSIDE_EDITOR &#x3D; 13
    }

    /**
     * Target hit with the mouse in the editor.
     */
    export interface IMouseTarget {
        /**
         * The target element
         */
        readonly element: Element | null;
        /**
         * The target type
         */
        readonly type: MouseTargetType;
        /**
         * The &#x27;approximate&#x27; editor position
         */
        readonly position: Position | null;
        /**
         * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).
         */
        readonly mouseColumn: number;
        /**
         * The &#x27;approximate&#x27; editor range
         */
        readonly range: Range | null;
        /**
         * Some extra detail.
         */
        readonly detail: any;
    }

    /**
     * A mouse event originating from the editor.
     */
    export interface IEditorMouseEvent {
        readonly event: IMouseEvent;
        readonly target: IMouseTarget;
    }

    export interface IPartialEditorMouseEvent {
        readonly event: IMouseEvent;
        readonly target: IMouseTarget | null;
    }

    /**
     * A paste event originating from the editor.
     */
    export interface IPasteEvent {
        readonly range: Range;
        readonly languageId: string | null;
    }

    export interface IEditorConstructionOptions extends IEditorOptions {
        /**
         * The initial editor dimension (to avoid measuring the container).
         */
        dimension?: IDimension;
        /**
         * Place overflow widgets inside an external DOM node.
         * Defaults to an internal DOM node.
         */
        overflowWidgetsDomNode?: HTMLElement;
    }

    export interface IDiffEditorConstructionOptions extends IDiffEditorOptions {
        /**
         * The initial editor dimension (to avoid measuring the container).
         */
        dimension?: IDimension;
        /**
         * Place overflow widgets inside an external DOM node.
         * Defaults to an internal DOM node.
         */
        overflowWidgetsDomNode?: HTMLElement;
        /**
         * Aria label for original editor.
         */
        originalAriaLabel?: string;
        /**
         * Aria label for modified editor.
         */
        modifiedAriaLabel?: string;
        /**
         * Is the diff editor inside another editor
         * Defaults to false
         */
        isInEmbeddedEditor?: boolean;
    }

    /**
     * A rich code editor.
     */
    export interface ICodeEditor extends IEditor {
        /**
         * An event emitted when the content of the current model has changed.
         * @event
         */
        onDidChangeModelContent: IEvent&lt;IModelContentChangedEvent&gt;;
        /**
         * An event emitted when the language of the current model has changed.
         * @event
         */
        onDidChangeModelLanguage: IEvent&lt;IModelLanguageChangedEvent&gt;;
        /**
         * An event emitted when the language configuration of the current model has changed.
         * @event
         */
        onDidChangeModelLanguageConfiguration: IEvent&lt;IModelLanguageConfigurationChangedEvent&gt;;
        /**
         * An event emitted when the options of the current model has changed.
         * @event
         */
        onDidChangeModelOptions: IEvent&lt;IModelOptionsChangedEvent&gt;;
        /**
         * An event emitted when the configuration of the editor has changed. (e.g. &#x60;editor.updateOptions()&#x60;)
         * @event
         */
        onDidChangeConfiguration: IEvent&lt;ConfigurationChangedEvent&gt;;
        /**
         * An event emitted when the cursor position has changed.
         * @event
         */
        onDidChangeCursorPosition: IEvent&lt;ICursorPositionChangedEvent&gt;;
        /**
         * An event emitted when the cursor selection has changed.
         * @event
         */
        onDidChangeCursorSelection: IEvent&lt;ICursorSelectionChangedEvent&gt;;
        /**
         * An event emitted when the model of this editor has changed (e.g. &#x60;editor.setModel()&#x60;).
         * @event
         */
        onDidChangeModel: IEvent&lt;IModelChangedEvent&gt;;
        /**
         * An event emitted when the decorations of the current model have changed.
         * @event
         */
        onDidChangeModelDecorations: IEvent&lt;IModelDecorationsChangedEvent&gt;;
        /**
         * An event emitted when the text inside this editor gained focus (i.e. cursor starts blinking).
         * @event
         */
        onDidFocusEditorText(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the text inside this editor lost focus (i.e. cursor stops blinking).
         * @event
         */
        onDidBlurEditorText(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the text inside this editor or an editor widget gained focus.
         * @event
         */
        onDidFocusEditorWidget(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when the text inside this editor or an editor widget lost focus.
         * @event
         */
        onDidBlurEditorWidget(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted after composition has started.
         */
        onDidCompositionStart(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted after composition has ended.
         */
        onDidCompositionEnd(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when editing failed because the editor is read-only.
         * @event
         */
        onDidAttemptReadOnlyEdit(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * An event emitted when users paste text in the editor.
         * @event
         */
        onDidPaste: IEvent&lt;IPasteEvent&gt;;
        /**
         * An event emitted on a &quot;mouseup&quot;.
         * @event
         */
        onMouseUp: IEvent&lt;IEditorMouseEvent&gt;;
        /**
         * An event emitted on a &quot;mousedown&quot;.
         * @event
         */
        onMouseDown: IEvent&lt;IEditorMouseEvent&gt;;
        /**
         * An event emitted on a &quot;contextmenu&quot;.
         * @event
         */
        onContextMenu: IEvent&lt;IEditorMouseEvent&gt;;
        /**
         * An event emitted on a &quot;mousemove&quot;.
         * @event
         */
        onMouseMove: IEvent&lt;IEditorMouseEvent&gt;;
        /**
         * An event emitted on a &quot;mouseleave&quot;.
         * @event
         */
        onMouseLeave: IEvent&lt;IPartialEditorMouseEvent&gt;;
        /**
         * An event emitted on a &quot;keyup&quot;.
         * @event
         */
        onKeyUp: IEvent&lt;IKeyboardEvent&gt;;
        /**
         * An event emitted on a &quot;keydown&quot;.
         * @event
         */
        onKeyDown: IEvent&lt;IKeyboardEvent&gt;;
        /**
         * An event emitted when the layout of the editor has changed.
         * @event
         */
        onDidLayoutChange: IEvent&lt;EditorLayoutInfo&gt;;
        /**
         * An event emitted when the content width or content height in the editor has changed.
         * @event
         */
        onDidContentSizeChange: IEvent&lt;IContentSizeChangedEvent&gt;;
        /**
         * An event emitted when the scroll in the editor has changed.
         * @event
         */
        onDidScrollChange: IEvent&lt;IScrollEvent&gt;;
        /**
         * An event emitted when hidden areas change in the editor (e.g. due to folding).
         * @event
         */
        onDidChangeHiddenAreas: IEvent&lt;void&gt;;
        /**
         * Saves current view state of the editor in a serializable object.
         */
        saveViewState(): ICodeEditorViewState | null;
        /**
         * Restores the view state of the editor from a serializable object generated by &#x60;saveViewState&#x60;.
         */
        restoreViewState(state: ICodeEditorViewState): void;
        /**
         * Returns true if the text inside this editor or an editor widget has focus.
         */
        hasWidgetFocus(): boolean;
        /**
         * Get a contribution of this editor.
         * @id Unique identifier of the contribution.
         * @return The contribution or null if contribution not found.
         */
        getContribution&lt;T extends IEditorContribution&gt;(id: string): T;
        /**
         * Type the getModel() of IEditor.
         */
        getModel(): ITextModel | null;
        /**
         * Sets the current model attached to this editor.
         * If the previous model was created by the editor via the value key in the options
         * literal object, it will be destroyed. Otherwise, if the previous model was set
         * via setModel, or the model key in the options literal object, the previous model
         * will not be destroyed.
         * It is safe to call setModel(null) to simply detach the current model from the editor.
         */
        setModel(model: ITextModel | null): void;
        /**
         * Gets all the editor computed options.
         */
        getOptions(): IComputedEditorOptions;
        /**
         * Gets a specific editor option.
         */
        getOption&lt;T extends EditorOption&gt;(id: T): FindComputedEditorOptionValueById&lt;T&gt;;
        /**
         * Returns the editor&#x27;s configuration (without any validation or defaults).
         */
        getRawOptions(): IEditorOptions;
        /**
         * Get value of the current model attached to this editor.
         * @see {@link ITextModel.getValue}
         */
        getValue(options?: {
            preserveBOM: boolean;
            lineEnding: string;
        }): string;
        /**
         * Set the value of the current model attached to this editor.
         * @see {@link ITextModel.setValue}
         */
        setValue(newValue: string): void;
        /**
         * Get the width of the editor&#x27;s content.
         * This is information that is &quot;erased&quot; when computing &#x60;scrollWidth &#x3D; Math.max(contentWidth, width)&#x60;
         */
        getContentWidth(): number;
        /**
         * Get the scrollWidth of the editor&#x27;s viewport.
         */
        getScrollWidth(): number;
        /**
         * Get the scrollLeft of the editor&#x27;s viewport.
         */
        getScrollLeft(): number;
        /**
         * Get the height of the editor&#x27;s content.
         * This is information that is &quot;erased&quot; when computing &#x60;scrollHeight &#x3D; Math.max(contentHeight, height)&#x60;
         */
        getContentHeight(): number;
        /**
         * Get the scrollHeight of the editor&#x27;s viewport.
         */
        getScrollHeight(): number;
        /**
         * Get the scrollTop of the editor&#x27;s viewport.
         */
        getScrollTop(): number;
        /**
         * Change the scrollLeft of the editor&#x27;s viewport.
         */
        setScrollLeft(newScrollLeft: number, scrollType?: ScrollType): void;
        /**
         * Change the scrollTop of the editor&#x27;s viewport.
         */
        setScrollTop(newScrollTop: number, scrollType?: ScrollType): void;
        /**
         * Change the scroll position of the editor&#x27;s viewport.
         */
        setScrollPosition(position: INewScrollPosition, scrollType?: ScrollType): void;
        /**
         * Get an action that is a contribution to this editor.
         * @id Unique identifier of the contribution.
         * @return The action or null if action not found.
         */
        getAction(id: string): IEditorAction;
        /**
         * Execute a command on the editor.
         * The edits will land on the undo-redo stack, but no &quot;undo stop&quot; will be pushed.
         * @param source The source of the call.
         * @param command The command to execute
         */
        executeCommand(source: string | null | undefined, command: ICommand): void;
        /**
         * Create an &quot;undo stop&quot; in the undo-redo stack.
         */
        pushUndoStop(): boolean;
        /**
         * Remove the &quot;undo stop&quot; in the undo-redo stack.
         */
        popUndoStop(): boolean;
        /**
         * Execute edits on the editor.
         * The edits will land on the undo-redo stack, but no &quot;undo stop&quot; will be pushed.
         * @param source The source of the call.
         * @param edits The edits to execute.
         * @param endCursorState Cursor state after the edits were applied.
         */
        executeEdits(source: string | null | undefined, edits: IIdentifiedSingleEditOperation[], endCursorState?: ICursorStateComputer | Selection[]): boolean;
        /**
         * Execute multiple (concomitant) commands on the editor.
         * @param source The source of the call.
         * @param command The commands to execute
         */
        executeCommands(source: string | null | undefined, commands: (ICommand | null)[]): void;
        /**
         * Get all the decorations on a line (filtering out decorations from other editors).
         */
        getLineDecorations(lineNumber: number): IModelDecoration[] | null;
        /**
         * All decorations added through this call will get the ownerId of this editor.
         * @see {@link ITextModel.deltaDecorations}
         */
        deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
        /**
         * Get the layout info for the editor.
         */
        getLayoutInfo(): EditorLayoutInfo;
        /**
         * Returns the ranges that are currently visible.
         * Does not account for horizontal scrolling.
         */
        getVisibleRanges(): Range[];
        /**
         * Get the vertical position (top offset) for the line w.r.t. to the first line.
         */
        getTopForLineNumber(lineNumber: number): number;
        /**
         * Get the vertical position (top offset) for the position w.r.t. to the first line.
         */
        getTopForPosition(lineNumber: number, column: number): number;
        /**
         * Returns the editor&#x27;s container dom node
         */
        getContainerDomNode(): HTMLElement;
        /**
         * Returns the editor&#x27;s dom node
         */
        getDomNode(): HTMLElement | null;
        /**
         * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.
         */
        addContentWidget(widget: IContentWidget): void;
        /**
         * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()
         * and update appropriately.
         */
        layoutContentWidget(widget: IContentWidget): void;
        /**
         * Remove a content widget.
         */
        removeContentWidget(widget: IContentWidget): void;
        /**
         * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.
         */
        addOverlayWidget(widget: IOverlayWidget): void;
        /**
         * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()
         * and update appropriately.
         */
        layoutOverlayWidget(widget: IOverlayWidget): void;
        /**
         * Remove an overlay widget.
         */
        removeOverlayWidget(widget: IOverlayWidget): void;
        /**
         * Change the view zones. View zones are lost when a new model is attached to the editor.
         */
        changeViewZones(callback: (accessor: IViewZoneChangeAccessor) &#x3D;&gt; void): void;
        /**
         * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.
         * This method works only if the line &#x60;lineNumber&#x60; is currently rendered (in the editor&#x27;s viewport).
         * Use this method with caution.
         */
        getOffsetForColumn(lineNumber: number, column: number): number;
        /**
         * Force an editor render now.
         */
        render(forceRedraw?: boolean): void;
        /**
         * Get the hit test target at coordinates &#x60;clientX&#x60; and &#x60;clientY&#x60;.
         * The coordinates are relative to the top-left of the viewport.
         *
         * @returns Hit test target or null if the coordinates fall outside the editor or the editor has no model.
         */
        getTargetAtClientPoint(clientX: number, clientY: number): IMouseTarget | null;
        /**
         * Get the visible position for &#x60;position&#x60;.
         * The result position takes scrolling into account and is relative to the top left corner of the editor.
         * Explanation 1: the results of this method will change for the same &#x60;position&#x60; if the user scrolls the editor.
         * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.
         * Warning: the results of this method are inaccurate for positions that are outside the current editor viewport.
         */
        getScrolledVisiblePosition(position: IPosition): {
            top: number;
            left: number;
            height: number;
        } | null;
        /**
         * Apply the same font settings as the editor to &#x60;target&#x60;.
         */
        applyFontInfo(target: HTMLElement): void;
        setBanner(bannerDomNode: HTMLElement | null, height: number): void;
    }

    /**
     * Information about a line in the diff editor
     */
    export interface IDiffLineInformation {
        readonly equivalentLineNumber: number;
    }

    /**
     * A rich diff editor.
     */
    export interface IDiffEditor extends IEditor {
        /**
         * @see {@link ICodeEditor.getDomNode}
         */
        getDomNode(): HTMLElement;
        /**
         * An event emitted when the diff information computed by this diff editor has been updated.
         * @event
         */
        onDidUpdateDiff(listener: () &#x3D;&gt; void): IDisposable;
        /**
         * Saves current view state of the editor in a serializable object.
         */
        saveViewState(): IDiffEditorViewState | null;
        /**
         * Restores the view state of the editor from a serializable object generated by &#x60;saveViewState&#x60;.
         */
        restoreViewState(state: IDiffEditorViewState): void;
        /**
         * Type the getModel() of IEditor.
         */
        getModel(): IDiffEditorModel | null;
        /**
         * Sets the current model attached to this editor.
         * If the previous model was created by the editor via the value key in the options
         * literal object, it will be destroyed. Otherwise, if the previous model was set
         * via setModel, or the model key in the options literal object, the previous model
         * will not be destroyed.
         * It is safe to call setModel(null) to simply detach the current model from the editor.
         */
        setModel(model: IDiffEditorModel | null): void;
        /**
         * Get the &#x60;original&#x60; editor.
         */
        getOriginalEditor(): ICodeEditor;
        /**
         * Get the &#x60;modified&#x60; editor.
         */
        getModifiedEditor(): ICodeEditor;
        /**
         * Get the computed diff information.
         */
        getLineChanges(): ILineChange[] | null;
        /**
         * Get information based on computed diff about a line number from the original model.
         * If the diff computation is not finished or the model is missing, will return null.
         */
        getDiffLineInformationForOriginal(lineNumber: number): IDiffLineInformation | null;
        /**
         * Get information based on computed diff about a line number from the modified model.
         * If the diff computation is not finished or the model is missing, will return null.
         */
        getDiffLineInformationForModified(lineNumber: number): IDiffLineInformation | null;
        /**
         * Update the editor&#x27;s options after the editor has been created.
         */
        updateOptions(newOptions: IDiffEditorOptions): void;
    }

    export class FontInfo extends BareFontInfo {
        readonly _editorStylingBrand: void;
        readonly version: number;
        readonly isTrusted: boolean;
        readonly isMonospace: boolean;
        readonly typicalHalfwidthCharacterWidth: number;
        readonly typicalFullwidthCharacterWidth: number;
        readonly canUseHalfwidthRightwardsArrow: boolean;
        readonly spaceWidth: number;
        readonly middotWidth: number;
        readonly wsmiddotWidth: number;
        readonly maxDigitWidth: number;
    }

    export class BareFontInfo {
        readonly _bareFontInfoBrand: void;
        readonly zoomLevel: number;
        readonly pixelRatio: number;
        readonly fontFamily: string;
        readonly fontWeight: string;
        readonly fontSize: number;
        readonly fontFeatureSettings: string;
        readonly lineHeight: number;
        readonly letterSpacing: number;
    }

    //compatibility:
    export type IReadOnlyModel &#x3D; ITextModel;
    export type IModel &#x3D; ITextModel;
}

declare namespace monaco.languages {


    /**
     * Register information about a new language.
     */
    export function register(language: ILanguageExtensionPoint): void;

    /**
     * Get the information of all the registered languages.
     */
    export function getLanguages(): ILanguageExtensionPoint[];

    export function getEncodedLanguageId(languageId: string): number;

    /**
     * An event emitted when a language is first time needed (e.g. a model has it set).
     * @event
     */
    export function onLanguage(languageId: string, callback: () &#x3D;&gt; void): IDisposable;

    /**
     * Set the editing configuration for a language.
     */
    export function setLanguageConfiguration(languageId: string, configuration: LanguageConfiguration): IDisposable;

    /**
     * A token.
     */
    export interface IToken {
        startIndex: number;
        scopes: string;
    }

    /**
     * The result of a line tokenization.
     */
    export interface ILineTokens {
        /**
         * The list of tokens on the line.
         */
        tokens: IToken[];
        /**
         * The tokenization end state.
         * A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
         */
        endState: IState;
    }

    /**
     * The result of a line tokenization.
     */
    export interface IEncodedLineTokens {
        /**
         * The tokens on the line in a binary, encoded format. Each token occupies two array indices. For token i:
         *  - at offset 2*i &#x3D;&gt; startIndex
         *  - at offset 2*i + 1 &#x3D;&gt; metadata
         * Meta data is in binary format:
         * - -------------------------------------------
         *     3322 2222 2222 1111 1111 1100 0000 0000
         *     1098 7654 3210 9876 5432 1098 7654 3210
         * - -------------------------------------------
         *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
         * - -------------------------------------------
         *  - L &#x3D; EncodedLanguageId (8 bits): Use &#x60;getEncodedLanguageId&#x60; to get the encoded ID of a language.
         *  - T &#x3D; StandardTokenType (3 bits): Other &#x3D; 0, Comment &#x3D; 1, String &#x3D; 2, RegEx &#x3D; 4.
         *  - F &#x3D; FontStyle (3 bits): None &#x3D; 0, Italic &#x3D; 1, Bold &#x3D; 2, Underline &#x3D; 4.
         *  - f &#x3D; foreground ColorId (9 bits)
         *  - b &#x3D; background ColorId (9 bits)
         *  - The color value for each colorId is defined in IStandaloneThemeData.customTokenColors:
         * e.g. colorId &#x3D; 1 is stored in IStandaloneThemeData.customTokenColors[1]. Color id &#x3D; 0 means no color,
         * id &#x3D; 1 is for the default foreground color, id &#x3D; 2 for the default background.
         */
        tokens: Uint32Array;
        /**
         * The tokenization end state.
         * A pointer will be held to this and the object should not be modified by the tokenizer after the pointer is returned.
         */
        endState: IState;
    }

    /**
     * A &quot;manual&quot; provider of tokens.
     */
    export interface TokensProvider {
        /**
         * The initial state of a language. Will be the state passed in to tokenize the first line.
         */
        getInitialState(): IState;
        /**
         * Tokenize a line given the state at the beginning of the line.
         */
        tokenize(line: string, state: IState): ILineTokens;
    }

    /**
     * A &quot;manual&quot; provider of tokens, returning tokens in a binary form.
     */
    export interface EncodedTokensProvider {
        /**
         * The initial state of a language. Will be the state passed in to tokenize the first line.
         */
        getInitialState(): IState;
        /**
         * Tokenize a line given the state at the beginning of the line.
         */
        tokenizeEncoded(line: string, state: IState): IEncodedLineTokens;
        /**
         * Tokenize a line given the state at the beginning of the line.
         */
        tokenize?(line: string, state: IState): ILineTokens;
    }

    /**
     * Change the color map that is used for token colors.
     * Supported formats (hex): #RRGGBB, $RRGGBBAA, #RGB, #RGBA
     */
    export function setColorMap(colorMap: string[] | null): void;

    /**
     * Set the tokens provider for a language (manual implementation).
     */
    export function setTokensProvider(languageId: string, provider: TokensProvider | EncodedTokensProvider | Thenable&lt;TokensProvider | EncodedTokensProvider&gt;): IDisposable;

    /**
     * Set the tokens provider for a language (monarch implementation).
     */
    export function setMonarchTokensProvider(languageId: string, languageDef: IMonarchLanguage | Thenable&lt;IMonarchLanguage&gt;): IDisposable;

    /**
     * Register a reference provider (used by e.g. reference search).
     */
    export function registerReferenceProvider(languageId: string, provider: ReferenceProvider): IDisposable;

    /**
     * Register a rename provider (used by e.g. rename symbol).
     */
    export function registerRenameProvider(languageId: string, provider: RenameProvider): IDisposable;

    /**
     * Register a signature help provider (used by e.g. parameter hints).
     */
    export function registerSignatureHelpProvider(languageId: string, provider: SignatureHelpProvider): IDisposable;

    /**
     * Register a hover provider (used by e.g. editor hover).
     */
    export function registerHoverProvider(languageId: string, provider: HoverProvider): IDisposable;

    /**
     * Register a document symbol provider (used by e.g. outline).
     */
    export function registerDocumentSymbolProvider(languageId: string, provider: DocumentSymbolProvider): IDisposable;

    /**
     * Register a document highlight provider (used by e.g. highlight occurrences).
     */
    export function registerDocumentHighlightProvider(languageId: string, provider: DocumentHighlightProvider): IDisposable;

    /**
     * Register an linked editing range provider.
     */
    export function registerLinkedEditingRangeProvider(languageId: string, provider: LinkedEditingRangeProvider): IDisposable;

    /**
     * Register a definition provider (used by e.g. go to definition).
     */
    export function registerDefinitionProvider(languageId: string, provider: DefinitionProvider): IDisposable;

    /**
     * Register a implementation provider (used by e.g. go to implementation).
     */
    export function registerImplementationProvider(languageId: string, provider: ImplementationProvider): IDisposable;

    /**
     * Register a type definition provider (used by e.g. go to type definition).
     */
    export function registerTypeDefinitionProvider(languageId: string, provider: TypeDefinitionProvider): IDisposable;

    /**
     * Register a code lens provider (used by e.g. inline code lenses).
     */
    export function registerCodeLensProvider(languageId: string, provider: CodeLensProvider): IDisposable;

    /**
     * Register a code action provider (used by e.g. quick fix).
     */
    export function registerCodeActionProvider(languageId: string, provider: CodeActionProvider, metadata?: CodeActionProviderMetadata): IDisposable;

    /**
     * Register a formatter that can handle only entire models.
     */
    export function registerDocumentFormattingEditProvider(languageId: string, provider: DocumentFormattingEditProvider): IDisposable;

    /**
     * Register a formatter that can handle a range inside a model.
     */
    export function registerDocumentRangeFormattingEditProvider(languageId: string, provider: DocumentRangeFormattingEditProvider): IDisposable;

    /**
     * Register a formatter than can do formatting as the user types.
     */
    export function registerOnTypeFormattingEditProvider(languageId: string, provider: OnTypeFormattingEditProvider): IDisposable;

    /**
     * Register a link provider that can find links in text.
     */
    export function registerLinkProvider(languageId: string, provider: LinkProvider): IDisposable;

    /**
     * Register a completion item provider (use by e.g. suggestions).
     */
    export function registerCompletionItemProvider(languageId: string, provider: CompletionItemProvider): IDisposable;

    /**
     * Register a document color provider (used by Color Picker, Color Decorator).
     */
    export function registerColorProvider(languageId: string, provider: DocumentColorProvider): IDisposable;

    /**
     * Register a folding range provider
     */
    export function registerFoldingRangeProvider(languageId: string, provider: FoldingRangeProvider): IDisposable;

    /**
     * Register a declaration provider
     */
    export function registerDeclarationProvider(languageId: string, provider: DeclarationProvider): IDisposable;

    /**
     * Register a selection range provider
     */
    export function registerSelectionRangeProvider(languageId: string, provider: SelectionRangeProvider): IDisposable;

    /**
     * Register a document semantic tokens provider
     */
    export function registerDocumentSemanticTokensProvider(languageId: string, provider: DocumentSemanticTokensProvider): IDisposable;

    /**
     * Register a document range semantic tokens provider
     */
    export function registerDocumentRangeSemanticTokensProvider(languageId: string, provider: DocumentRangeSemanticTokensProvider): IDisposable;

    /**
     * Register an inline completions provider.
     */
    export function registerInlineCompletionsProvider(languageId: string, provider: InlineCompletionsProvider): IDisposable;

    /**
     * Register an inlay hints provider.
     */
    export function registerInlayHintsProvider(languageId: string, provider: InlayHintsProvider): IDisposable;

    /**
     * Contains additional diagnostic information about the context in which
     * a [code action](#CodeActionProvider.provideCodeActions) is run.
     */
    export interface CodeActionContext {
        /**
         * An array of diagnostics.
         */
        readonly markers: editor.IMarkerData[];
        /**
         * Requested kind of actions to return.
         */
        readonly only?: string;
    }

    /**
     * The code action interface defines the contract between extensions and
     * the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
     */
    export interface CodeActionProvider {
        /**
         * Provide commands for the given document and range.
         */
        provideCodeActions(model: editor.ITextModel, range: Range, context: CodeActionContext, token: CancellationToken): ProviderResult&lt;CodeActionList&gt;;
        /**
         * Given a code action fill in the edit. Will only invoked when missing.
         */
        resolveCodeAction?(codeAction: CodeAction, token: CancellationToken): ProviderResult&lt;CodeAction&gt;;
    }

    /**
     * Metadata about the type of code actions that a {@link CodeActionProvider} provides.
     */
    export interface CodeActionProviderMetadata {
        /**
         * List of code action kinds that a {@link CodeActionProvider} may return.
         *
         * This list is used to determine if a given &#x60;CodeActionProvider&#x60; should be invoked or not.
         * To avoid unnecessary computation, every &#x60;CodeActionProvider&#x60; should list use &#x60;providedCodeActionKinds&#x60;. The
         * list of kinds may either be generic, such as &#x60;[&quot;quickfix&quot;, &quot;refactor&quot;, &quot;source&quot;]&#x60;, or list out every kind provided,
         * such as &#x60;[&quot;quickfix.removeLine&quot;, &quot;source.fixAll&quot; ...]&#x60;.
         */
        readonly providedCodeActionKinds?: readonly string[];
    }

    /**
     * Describes how comments for a language work.
     */
    export interface CommentRule {
        /**
         * The line comment token, like &#x60;// this is a comment&#x60;
         */
        lineComment?: string | null;
        /**
         * The block comment character pair, like &#x60;/* block comment *&amp;#47;&#x60;
         */
        blockComment?: CharacterPair | null;
    }

    /**
     * The language configuration interface defines the contract between extensions and
     * various editor features, like automatic bracket insertion, automatic indentation etc.
     */
    export interface LanguageConfiguration {
        /**
         * The language&#x27;s comment settings.
         */
        comments?: CommentRule;
        /**
         * The language&#x27;s brackets.
         * This configuration implicitly affects pressing Enter around these brackets.
         */
        brackets?: CharacterPair[];
        /**
         * The language&#x27;s word definition.
         * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
         * to provide a word definition that uses exclusion of known separators.
         * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
         *   /(-?\d*\.\d\w*)|([^\&#x60;\~\!\@\#\%\^\&amp;\*\(\)\-\&#x3D;\+\[\{\]\}\\\|\;\:\&#x27;\&quot;\,\.\&lt;\&gt;\/\?\s]+)/g
         */
        wordPattern?: RegExp;
        /**
         * The language&#x27;s indentation settings.
         */
        indentationRules?: IndentationRule;
        /**
         * The language&#x27;s rules to be evaluated when pressing Enter.
         */
        onEnterRules?: OnEnterRule[];
        /**
         * The language&#x27;s auto closing pairs. The &#x27;close&#x27; character is automatically inserted with the
         * &#x27;open&#x27; character is typed. If not set, the configured brackets will be used.
         */
        autoClosingPairs?: IAutoClosingPairConditional[];
        /**
         * The language&#x27;s surrounding pairs. When the &#x27;open&#x27; character is typed on a selection, the
         * selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
         * settings will be used.
         */
        surroundingPairs?: IAutoClosingPair[];
        /**
         * Defines a list of bracket pairs that are colorized depending on their nesting level.
         * If not set, the configured brackets will be used.
        */
        colorizedBracketPairs?: CharacterPair[];
        /**
         * Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \&#x27;languageDefined\&#x27; autoclosing setting.
         *
         * This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
         */
        autoCloseBefore?: string;
        /**
         * The language&#x27;s folding rules.
         */
        folding?: FoldingRules;
        /**
         * **Deprecated** Do not use.
         *
         * @deprecated Will be replaced by a better API soon.
         */
        __electricCharacterSupport?: {
            docComment?: IDocComment;
        };
    }

    /**
     * Describes indentation rules for a language.
     */
    export interface IndentationRule {
        /**
         * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
         */
        decreaseIndentPattern: RegExp;
        /**
         * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
         */
        increaseIndentPattern: RegExp;
        /**
         * If a line matches this pattern, then **only the next line** after it should be indented once.
         */
        indentNextLinePattern?: RegExp | null;
        /**
         * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
         */
        unIndentedLinePattern?: RegExp | null;
    }

    /**
     * Describes language specific folding markers such as &#x27;#region&#x27; and &#x27;#endregion&#x27;.
     * The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
     * - the regex should start with &#x27;^&#x27;
     * - regexp flags (i, g) are ignored
     */
    export interface FoldingMarkers {
        start: RegExp;
        end: RegExp;
    }

    /**
     * Describes folding rules for a language.
     */
    export interface FoldingRules {
        /**
         * Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
         * A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
         * See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
         * If not set, &#x60;false&#x60; is used and empty lines belong to the previous block.
         */
        offSide?: boolean;
        /**
         * Region markers used by the language.
         */
        markers?: FoldingMarkers;
    }

    /**
     * Describes a rule to be evaluated when pressing Enter.
     */
    export interface OnEnterRule {
        /**
         * This rule will only execute if the text before the cursor matches this regular expression.
         */
        beforeText: RegExp;
        /**
         * This rule will only execute if the text after the cursor matches this regular expression.
         */
        afterText?: RegExp;
        /**
         * This rule will only execute if the text above the this line matches this regular expression.
         */
        previousLineText?: RegExp;
        /**
         * The action to execute.
         */
        action: EnterAction;
    }

    /**
     * Definition of documentation comments (e.g. Javadoc/JSdoc)
     */
    export interface IDocComment {
        /**
         * The string that starts a doc comment (e.g. &#x27;/**&#x27;)
         */
        open: string;
        /**
         * The string that appears on the last line and closes the doc comment (e.g. &#x27; * /&#x27;).
         */
        close?: string;
    }

    /**
     * A tuple of two characters, like a pair of
     * opening and closing brackets.
     */
    export type CharacterPair &#x3D; [string, string];

    export interface IAutoClosingPair {
        open: string;
        close: string;
    }

    export interface IAutoClosingPairConditional extends IAutoClosingPair {
        notIn?: string[];
    }

    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    export enum IndentAction {
        /**
         * Insert new line and copy the previous line&#x27;s indentation.
         */
        None &#x3D; 0,
        /**
         * Insert new line and indent once (relative to the previous line&#x27;s indentation).
         */
        Indent &#x3D; 1,
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentOutdent &#x3D; 2,
        /**
         * Insert new line and outdent once (relative to the previous line&#x27;s indentation).
         */
        Outdent &#x3D; 3
    }

    /**
     * Describes what to do when pressing Enter.
     */
    export interface EnterAction {
        /**
         * Describe what to do with the indentation.
         */
        indentAction: IndentAction;
        /**
         * Describes text to be appended after the new line and after the indentation.
         */
        appendText?: string;
        /**
         * Describes the number of characters to remove from the new line&#x27;s indentation.
         */
        removeText?: number;
    }

    /**
     * The state of the tokenizer between two lines.
     * It is useful to store flags such as in multiline comment, etc.
     * The model will clone the previous line&#x27;s state and pass it in to tokenize the next line.
     */
    export interface IState {
        clone(): IState;
        equals(other: IState): boolean;
    }

    /**
     * A provider result represents the values a provider, like the {@link HoverProvider},
     * may return. For once this is the actual result type &#x60;T&#x60;, like &#x60;Hover&#x60;, or a thenable that resolves
     * to that type &#x60;T&#x60;. In addition, &#x60;null&#x60; and &#x60;undefined&#x60; can be returned - either directly or from a
     * thenable.
     */
    export type ProviderResult&lt;T&gt; &#x3D; T | undefined | null | Thenable&lt;T | undefined | null&gt;;

    /**
     * A hover represents additional information for a symbol or word. Hovers are
     * rendered in a tooltip-like widget.
     */
    export interface Hover {
        /**
         * The contents of this hover.
         */
        contents: IMarkdownString[];
        /**
         * The range to which this hover applies. When missing, the
         * editor will use the range at the current position or the
         * current position itself.
         */
        range?: IRange;
    }

    /**
     * The hover provider interface defines the contract between extensions and
     * the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
     */
    export interface HoverProvider {
        /**
         * Provide a hover for the given position and document. Multiple hovers at the same
         * position will be merged by the editor. A hover can have a range which defaults
         * to the word range at the position when omitted.
         */
        provideHover(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;Hover&gt;;
    }

    export enum CompletionItemKind {
        Method &#x3D; 0,
        Function &#x3D; 1,
        Constructor &#x3D; 2,
        Field &#x3D; 3,
        Variable &#x3D; 4,
        Class &#x3D; 5,
        Struct &#x3D; 6,
        Interface &#x3D; 7,
        Module &#x3D; 8,
        Property &#x3D; 9,
        Event &#x3D; 10,
        Operator &#x3D; 11,
        Unit &#x3D; 12,
        Value &#x3D; 13,
        Constant &#x3D; 14,
        Enum &#x3D; 15,
        EnumMember &#x3D; 16,
        Keyword &#x3D; 17,
        Text &#x3D; 18,
        Color &#x3D; 19,
        File &#x3D; 20,
        Reference &#x3D; 21,
        Customcolor &#x3D; 22,
        Folder &#x3D; 23,
        TypeParameter &#x3D; 24,
        User &#x3D; 25,
        Issue &#x3D; 26,
        Snippet &#x3D; 27
    }

    export interface CompletionItemLabel {
        label: string;
        detail?: string;
        description?: string;
    }

    export enum CompletionItemTag {
        Deprecated &#x3D; 1
    }

    export enum CompletionItemInsertTextRule {
        /**
         * Adjust whitespace/indentation of multiline insert texts to
         * match the current line indentation.
         */
        KeepWhitespace &#x3D; 1,
        /**
         * &#x60;insertText&#x60; is a snippet.
         */
        InsertAsSnippet &#x3D; 4
    }

    export interface CompletionItemRanges {
        insert: IRange;
        replace: IRange;
    }

    /**
     * A completion item represents a text snippet that is
     * proposed to complete text that is being typed.
     */
    export interface CompletionItem {
        /**
         * The label of this completion item. By default
         * this is also the text that is inserted when selecting
         * this completion.
         */
        label: string | CompletionItemLabel;
        /**
         * The kind of this completion item. Based on the kind
         * an icon is chosen by the editor.
         */
        kind: CompletionItemKind;
        /**
         * A modifier to the &#x60;kind&#x60; which affect how the item
         * is rendered, e.g. Deprecated is rendered with a strikeout
         */
        tags?: ReadonlyArray&lt;CompletionItemTag&gt;;
        /**
         * A human-readable string with additional information
         * about this item, like type or symbol information.
         */
        detail?: string;
        /**
         * A human-readable string that represents a doc-comment.
         */
        documentation?: string | IMarkdownString;
        /**
         * A string that should be used when comparing this item
         * with other items. When &#x60;falsy&#x60; the {@link CompletionItem.label label}
         * is used.
         */
        sortText?: string;
        /**
         * A string that should be used when filtering a set of
         * completion items. When &#x60;falsy&#x60; the {@link CompletionItem.label label}
         * is used.
         */
        filterText?: string;
        /**
         * Select this item when showing. *Note* that only one completion item can be selected and
         * that the editor decides which item that is. The rule is that the *first* item of those
         * that match best is selected.
         */
        preselect?: boolean;
        /**
         * A string or snippet that should be inserted in a document when selecting
         * this completion.
         */
        insertText: string;
        /**
         * Additional rules (as bitmask) that should be applied when inserting
         * this completion.
         */
        insertTextRules?: CompletionItemInsertTextRule;
        /**
         * A range of text that should be replaced by this completion item.
         *
         * Defaults to a range from the start of the {@link TextDocument.getWordRangeAtPosition current word} to the
         * current position.
         *
         * *Note:* The range must be a {@link Range.isSingleLine single line} and it must
         * {@link Range.contains contain} the position at which completion has been {@link CompletionItemProvider.provideCompletionItems requested}.
         */
        range: IRange | CompletionItemRanges;
        /**
         * An optional set of characters that when pressed while this completion is active will accept it first and
         * then type that character. *Note* that all commit characters should have &#x60;length&#x3D;1&#x60; and that superfluous
         * characters will be ignored.
         */
        commitCharacters?: string[];
        /**
         * An optional array of additional text edits that are applied when
         * selecting this completion. Edits must not overlap with the main edit
         * nor with themselves.
         */
        additionalTextEdits?: editor.ISingleEditOperation[];
        /**
         * A command that should be run upon acceptance of this item.
         */
        command?: Command;
    }

    export interface CompletionList {
        suggestions: CompletionItem[];
        incomplete?: boolean;
        dispose?(): void;
    }

    /**
     * How a suggest provider was triggered.
     */
    export enum CompletionTriggerKind {
        Invoke &#x3D; 0,
        TriggerCharacter &#x3D; 1,
        TriggerForIncompleteCompletions &#x3D; 2
    }

    /**
     * Contains additional information about the context in which
     * {@link CompletionItemProvider.provideCompletionItems completion provider} is triggered.
     */
    export interface CompletionContext {
        /**
         * How the completion was triggered.
         */
        triggerKind: CompletionTriggerKind;
        /**
         * Character that triggered the completion item provider.
         *
         * &#x60;undefined&#x60; if provider was not triggered by a character.
         */
        triggerCharacter?: string;
    }

    /**
     * The completion item provider interface defines the contract between extensions and
     * the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense).
     *
     * When computing *complete* completion items is expensive, providers can optionally implement
     * the &#x60;resolveCompletionItem&#x60;-function. In that case it is enough to return completion
     * items with a {@link CompletionItem.label label} from the
     * {@link CompletionItemProvider.provideCompletionItems provideCompletionItems}-function. Subsequently,
     * when a completion item is shown in the UI and gains focus this provider is asked to resolve
     * the item, like adding {@link CompletionItem.documentation doc-comment} or {@link CompletionItem.detail details}.
     */
    export interface CompletionItemProvider {
        triggerCharacters?: string[];
        /**
         * Provide completion items for the given position and document.
         */
        provideCompletionItems(model: editor.ITextModel, position: Position, context: CompletionContext, token: CancellationToken): ProviderResult&lt;CompletionList&gt;;
        /**
         * Given a completion item fill in more data, like {@link CompletionItem.documentation doc-comment}
         * or {@link CompletionItem.detail details}.
         *
         * The editor will only resolve a completion item once.
         */
        resolveCompletionItem?(item: CompletionItem, token: CancellationToken): ProviderResult&lt;CompletionItem&gt;;
    }

    /**
     * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
     */
    export enum InlineCompletionTriggerKind {
        /**
         * Completion was triggered automatically while editing.
         * It is sufficient to return a single completion item in this case.
         */
        Automatic &#x3D; 0,
        /**
         * Completion was triggered explicitly by a user gesture.
         * Return multiple completion items to enable cycling through them.
         */
        Explicit &#x3D; 1
    }

    export interface InlineCompletionContext {
        /**
         * How the completion was triggered.
         */
        readonly triggerKind: InlineCompletionTriggerKind;
        readonly selectedSuggestionInfo: SelectedSuggestionInfo | undefined;
    }

    export interface SelectedSuggestionInfo {
        range: IRange;
        text: string;
        isSnippetText: boolean;
        completionKind: CompletionItemKind;
    }

    export interface InlineCompletion {
        /**
         * The text to insert.
         * If the text contains a line break, the range must end at the end of a line.
         * If existing text should be replaced, the existing text must be a prefix of the text to insert.
        */
        readonly text: string;
        /**
         * The range to replace.
         * Must begin and end on the same line.
        */
        readonly range?: IRange;
        readonly command?: Command;
    }

    export interface InlineCompletions&lt;TItem extends InlineCompletion &#x3D; InlineCompletion&gt; {
        readonly items: readonly TItem[];
    }

    export interface InlineCompletionsProvider&lt;T extends InlineCompletions &#x3D; InlineCompletions&gt; {
        provideInlineCompletions(model: editor.ITextModel, position: Position, context: InlineCompletionContext, token: CancellationToken): ProviderResult&lt;T&gt;;
        /**
         * Will be called when an item is shown.
        */
        handleItemDidShow?(completions: T, item: T[&#x27;items&#x27;][number]): void;
        /**
         * Will be called when a completions list is no longer in use and can be garbage-collected.
        */
        freeInlineCompletions(completions: T): void;
    }

    export interface CodeAction {
        title: string;
        command?: Command;
        edit?: WorkspaceEdit;
        diagnostics?: editor.IMarkerData[];
        kind?: string;
        isPreferred?: boolean;
        disabled?: string;
    }

    export interface CodeActionList extends IDisposable {
        readonly actions: ReadonlyArray&lt;CodeAction&gt;;
    }

    /**
     * Represents a parameter of a callable-signature. A parameter can
     * have a label and a doc-comment.
     */
    export interface ParameterInformation {
        /**
         * The label of this signature. Will be shown in
         * the UI.
         */
        label: string | [number, number];
        /**
         * The human-readable doc-comment of this signature. Will be shown
         * in the UI but can be omitted.
         */
        documentation?: string | IMarkdownString;
    }

    /**
     * Represents the signature of something callable. A signature
     * can have a label, like a function-name, a doc-comment, and
     * a set of parameters.
     */
    export interface SignatureInformation {
        /**
         * The label of this signature. Will be shown in
         * the UI.
         */
        label: string;
        /**
         * The human-readable doc-comment of this signature. Will be shown
         * in the UI but can be omitted.
         */
        documentation?: string | IMarkdownString;
        /**
         * The parameters of this signature.
         */
        parameters: ParameterInformation[];
        /**
         * Index of the active parameter.
         *
         * If provided, this is used in place of &#x60;SignatureHelp.activeSignature&#x60;.
         */
        activeParameter?: number;
    }

    /**
     * Signature help represents the signature of something
     * callable. There can be multiple signatures but only one
     * active and only one active parameter.
     */
    export interface SignatureHelp {
        /**
         * One or more signatures.
         */
        signatures: SignatureInformation[];
        /**
         * The active signature.
         */
        activeSignature: number;
        /**
         * The active parameter of the active signature.
         */
        activeParameter: number;
    }

    export interface SignatureHelpResult extends IDisposable {
        value: SignatureHelp;
    }

    export enum SignatureHelpTriggerKind {
        Invoke &#x3D; 1,
        TriggerCharacter &#x3D; 2,
        ContentChange &#x3D; 3
    }

    export interface SignatureHelpContext {
        readonly triggerKind: SignatureHelpTriggerKind;
        readonly triggerCharacter?: string;
        readonly isRetrigger: boolean;
        readonly activeSignatureHelp?: SignatureHelp;
    }

    /**
     * The signature help provider interface defines the contract between extensions and
     * the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
     */
    export interface SignatureHelpProvider {
        readonly signatureHelpTriggerCharacters?: ReadonlyArray&lt;string&gt;;
        readonly signatureHelpRetriggerCharacters?: ReadonlyArray&lt;string&gt;;
        /**
         * Provide help for the signature at the given position and document.
         */
        provideSignatureHelp(model: editor.ITextModel, position: Position, token: CancellationToken, context: SignatureHelpContext): ProviderResult&lt;SignatureHelpResult&gt;;
    }

    /**
     * A document highlight kind.
     */
    export enum DocumentHighlightKind {
        /**
         * A textual occurrence.
         */
        Text &#x3D; 0,
        /**
         * Read-access of a symbol, like reading a variable.
         */
        Read &#x3D; 1,
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        Write &#x3D; 2
    }

    /**
     * A document highlight is a range inside a text document which deserves
     * special attention. Usually a document highlight is visualized by changing
     * the background color of its range.
     */
    export interface DocumentHighlight {
        /**
         * The range this highlight applies to.
         */
        range: IRange;
        /**
         * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
         */
        kind?: DocumentHighlightKind;
    }

    /**
     * The document highlight provider interface defines the contract between extensions and
     * the word-highlight-feature.
     */
    export interface DocumentHighlightProvider {
        /**
         * Provide a set of document highlights, like all occurrences of a variable or
         * all exit-points of a function.
         */
        provideDocumentHighlights(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;DocumentHighlight[]&gt;;
    }

    /**
     * The linked editing range provider interface defines the contract between extensions and
     * the linked editing feature.
     */
    export interface LinkedEditingRangeProvider {
        /**
         * Provide a list of ranges that can be edited together.
         */
        provideLinkedEditingRanges(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;LinkedEditingRanges&gt;;
    }

    /**
     * Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.
     */
    export interface LinkedEditingRanges {
        /**
         * A list of ranges that can be edited together. The ranges must have
         * identical length and text content. The ranges cannot overlap
         */
        ranges: IRange[];
        /**
         * An optional word pattern that describes valid contents for the given ranges.
         * If no pattern is provided, the language configuration&#x27;s word pattern will be used.
         */
        wordPattern?: RegExp;
    }

    /**
     * Value-object that contains additional information when
     * requesting references.
     */
    export interface ReferenceContext {
        /**
         * Include the declaration of the current symbol.
         */
        includeDeclaration: boolean;
    }

    /**
     * The reference provider interface defines the contract between extensions and
     * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
     */
    export interface ReferenceProvider {
        /**
         * Provide a set of project-wide references for the given position and document.
         */
        provideReferences(model: editor.ITextModel, position: Position, context: ReferenceContext, token: CancellationToken): ProviderResult&lt;Location[]&gt;;
    }

    /**
     * Represents a location inside a resource, such as a line
     * inside a text file.
     */
    export interface Location {
        /**
         * The resource identifier of this location.
         */
        uri: Uri;
        /**
         * The document range of this locations.
         */
        range: IRange;
    }

    export interface LocationLink {
        /**
         * A range to select where this link originates from.
         */
        originSelectionRange?: IRange;
        /**
         * The target uri this link points to.
         */
        uri: Uri;
        /**
         * The full range this link points to.
         */
        range: IRange;
        /**
         * A range to select this link points to. Must be contained
         * in &#x60;LocationLink.range&#x60;.
         */
        targetSelectionRange?: IRange;
    }

    export type Definition &#x3D; Location | Location[] | LocationLink[];

    /**
     * The definition provider interface defines the contract between extensions and
     * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
     * and peek definition features.
     */
    export interface DefinitionProvider {
        /**
         * Provide the definition of the symbol at the given position and document.
         */
        provideDefinition(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;Definition | LocationLink[]&gt;;
    }

    /**
     * The definition provider interface defines the contract between extensions and
     * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
     * and peek definition features.
     */
    export interface DeclarationProvider {
        /**
         * Provide the declaration of the symbol at the given position and document.
         */
        provideDeclaration(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;Definition | LocationLink[]&gt;;
    }

    /**
     * The implementation provider interface defines the contract between extensions and
     * the go to implementation feature.
     */
    export interface ImplementationProvider {
        /**
         * Provide the implementation of the symbol at the given position and document.
         */
        provideImplementation(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;Definition | LocationLink[]&gt;;
    }

    /**
     * The type definition provider interface defines the contract between extensions and
     * the go to type definition feature.
     */
    export interface TypeDefinitionProvider {
        /**
         * Provide the type definition of the symbol at the given position and document.
         */
        provideTypeDefinition(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;Definition | LocationLink[]&gt;;
    }

    /**
     * A symbol kind.
     */
    export enum SymbolKind {
        File &#x3D; 0,
        Module &#x3D; 1,
        Namespace &#x3D; 2,
        Package &#x3D; 3,
        Class &#x3D; 4,
        Method &#x3D; 5,
        Property &#x3D; 6,
        Field &#x3D; 7,
        Constructor &#x3D; 8,
        Enum &#x3D; 9,
        Interface &#x3D; 10,
        Function &#x3D; 11,
        Variable &#x3D; 12,
        Constant &#x3D; 13,
        String &#x3D; 14,
        Number &#x3D; 15,
        Boolean &#x3D; 16,
        Array &#x3D; 17,
        Object &#x3D; 18,
        Key &#x3D; 19,
        Null &#x3D; 20,
        EnumMember &#x3D; 21,
        Struct &#x3D; 22,
        Event &#x3D; 23,
        Operator &#x3D; 24,
        TypeParameter &#x3D; 25
    }

    export enum SymbolTag {
        Deprecated &#x3D; 1
    }

    export interface DocumentSymbol {
        name: string;
        detail: string;
        kind: SymbolKind;
        tags: ReadonlyArray&lt;SymbolTag&gt;;
        containerName?: string;
        range: IRange;
        selectionRange: IRange;
        children?: DocumentSymbol[];
    }

    /**
     * The document symbol provider interface defines the contract between extensions and
     * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
     */
    export interface DocumentSymbolProvider {
        displayName?: string;
        /**
         * Provide symbol information for the given document.
         */
        provideDocumentSymbols(model: editor.ITextModel, token: CancellationToken): ProviderResult&lt;DocumentSymbol[]&gt;;
    }

    export type TextEdit &#x3D; {
        range: IRange;
        text: string;
        eol?: editor.EndOfLineSequence;
    };

    /**
     * Interface used to format a model
     */
    export interface FormattingOptions {
        /**
         * Size of a tab in spaces.
         */
        tabSize: number;
        /**
         * Prefer spaces over tabs.
         */
        insertSpaces: boolean;
    }

    /**
     * The document formatting provider interface defines the contract between extensions and
     * the formatting-feature.
     */
    export interface DocumentFormattingEditProvider {
        readonly displayName?: string;
        /**
         * Provide formatting edits for a whole document.
         */
        provideDocumentFormattingEdits(model: editor.ITextModel, options: FormattingOptions, token: CancellationToken): ProviderResult&lt;TextEdit[]&gt;;
    }

    /**
     * The document formatting provider interface defines the contract between extensions and
     * the formatting-feature.
     */
    export interface DocumentRangeFormattingEditProvider {
        readonly displayName?: string;
        /**
         * Provide formatting edits for a range in a document.
         *
         * The given range is a hint and providers can decide to format a smaller
         * or larger range. Often this is done by adjusting the start and end
         * of the range to full syntax nodes.
         */
        provideDocumentRangeFormattingEdits(model: editor.ITextModel, range: Range, options: FormattingOptions, token: CancellationToken): ProviderResult&lt;TextEdit[]&gt;;
    }

    /**
     * The document formatting provider interface defines the contract between extensions and
     * the formatting-feature.
     */
    export interface OnTypeFormattingEditProvider {
        autoFormatTriggerCharacters: string[];
        /**
         * Provide formatting edits after a character has been typed.
         *
         * The given position and character should hint to the provider
         * what range the position to expand to, like find the matching &#x60;{&#x60;
         * when &#x60;}&#x60; has been entered.
         */
        provideOnTypeFormattingEdits(model: editor.ITextModel, position: Position, ch: string, options: FormattingOptions, token: CancellationToken): ProviderResult&lt;TextEdit[]&gt;;
    }

    /**
     * A link inside the editor.
     */
    export interface ILink {
        range: IRange;
        url?: Uri | string;
        tooltip?: string;
    }

    export interface ILinksList {
        links: ILink[];
        dispose?(): void;
    }

    /**
     * A provider of links.
     */
    export interface LinkProvider {
        provideLinks(model: editor.ITextModel, token: CancellationToken): ProviderResult&lt;ILinksList&gt;;
        resolveLink?: (link: ILink, token: CancellationToken) &#x3D;&gt; ProviderResult&lt;ILink&gt;;
    }

    /**
     * A color in RGBA format.
     */
    export interface IColor {
        /**
         * The red component in the range [0-1].
         */
        readonly red: number;
        /**
         * The green component in the range [0-1].
         */
        readonly green: number;
        /**
         * The blue component in the range [0-1].
         */
        readonly blue: number;
        /**
         * The alpha component in the range [0-1].
         */
        readonly alpha: number;
    }

    /**
     * String representations for a color
     */
    export interface IColorPresentation {
        /**
         * The label of this color presentation. It will be shown on the color
         * picker header. By default this is also the text that is inserted when selecting
         * this color presentation.
         */
        label: string;
        /**
         * An {@link TextEdit edit} which is applied to a document when selecting
         * this presentation for the color.
         */
        textEdit?: TextEdit;
        /**
         * An optional array of additional {@link TextEdit text edits} that are applied when
         * selecting this color presentation.
         */
        additionalTextEdits?: TextEdit[];
    }

    /**
     * A color range is a range in a text model which represents a color.
     */
    export interface IColorInformation {
        /**
         * The range within the model.
         */
        range: IRange;
        /**
         * The color represented in this range.
         */
        color: IColor;
    }

    /**
     * A provider of colors for editor models.
     */
    export interface DocumentColorProvider {
        /**
         * Provides the color ranges for a specific model.
         */
        provideDocumentColors(model: editor.ITextModel, token: CancellationToken): ProviderResult&lt;IColorInformation[]&gt;;
        /**
         * Provide the string representations for a color.
         */
        provideColorPresentations(model: editor.ITextModel, colorInfo: IColorInformation, token: CancellationToken): ProviderResult&lt;IColorPresentation[]&gt;;
    }

    export interface SelectionRange {
        range: IRange;
    }

    export interface SelectionRangeProvider {
        /**
         * Provide ranges that should be selected from the given position.
         */
        provideSelectionRanges(model: editor.ITextModel, positions: Position[], token: CancellationToken): ProviderResult&lt;SelectionRange[][]&gt;;
    }

    export interface FoldingContext {
    }

    /**
     * A provider of folding ranges for editor models.
     */
    export interface FoldingRangeProvider {
        /**
         * An optional event to signal that the folding ranges from this provider have changed.
         */
        onDidChange?: IEvent&lt;this&gt;;
        /**
         * Provides the folding ranges for a specific model.
         */
        provideFoldingRanges(model: editor.ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult&lt;FoldingRange[]&gt;;
    }

    export interface FoldingRange {
        /**
         * The one-based start line of the range to fold. The folded area starts after the line&#x27;s last character.
         */
        start: number;
        /**
         * The one-based end line of the range to fold. The folded area ends with the line&#x27;s last character.
         */
        end: number;
        /**
         * Describes the {@link FoldingRangeKind Kind} of the folding range such as {@link FoldingRangeKind.Comment Comment} or
         * {@link FoldingRangeKind.Region Region}. The kind is used to categorize folding ranges and used by commands
         * like &#x27;Fold all comments&#x27;. See
         * {@link FoldingRangeKind} for an enumeration of standardized kinds.
         */
        kind?: FoldingRangeKind;
    }

    export class FoldingRangeKind {
        value: string;
        /**
         * Kind for folding range representing a comment. The value of the kind is &#x27;comment&#x27;.
         */
        static readonly Comment: FoldingRangeKind;
        /**
         * Kind for folding range representing a import. The value of the kind is &#x27;imports&#x27;.
         */
        static readonly Imports: FoldingRangeKind;
        /**
         * Kind for folding range representing regions (for example marked by &#x60;#region&#x60;, &#x60;#endregion&#x60;).
         * The value of the kind is &#x27;region&#x27;.
         */
        static readonly Region: FoldingRangeKind;
        /**
         * Creates a new {@link FoldingRangeKind}.
         *
         * @param value of the kind.
         */
        constructor(value: string);
    }

    export interface WorkspaceEditMetadata {
        needsConfirmation: boolean;
        label: string;
        description?: string;
    }

    export interface WorkspaceFileEditOptions {
        overwrite?: boolean;
        ignoreIfNotExists?: boolean;
        ignoreIfExists?: boolean;
        recursive?: boolean;
        copy?: boolean;
        folder?: boolean;
        skipTrashBin?: boolean;
        maxSize?: number;
    }

    export interface WorkspaceFileEdit {
        oldUri?: Uri;
        newUri?: Uri;
        options?: WorkspaceFileEditOptions;
        metadata?: WorkspaceEditMetadata;
    }

    export interface WorkspaceTextEdit {
        resource: Uri;
        edit: TextEdit;
        modelVersionId?: number;
        metadata?: WorkspaceEditMetadata;
    }

    export interface WorkspaceEdit {
        edits: Array&lt;WorkspaceTextEdit | WorkspaceFileEdit&gt;;
    }

    export interface Rejection {
        rejectReason?: string;
    }

    export interface RenameLocation {
        range: IRange;
        text: string;
    }

    export interface RenameProvider {
        provideRenameEdits(model: editor.ITextModel, position: Position, newName: string, token: CancellationToken): ProviderResult&lt;WorkspaceEdit &amp; Rejection&gt;;
        resolveRenameLocation?(model: editor.ITextModel, position: Position, token: CancellationToken): ProviderResult&lt;RenameLocation &amp; Rejection&gt;;
    }

    export interface Command {
        id: string;
        title: string;
        tooltip?: string;
        arguments?: any[];
    }

    export interface CodeLens {
        range: IRange;
        id?: string;
        command?: Command;
    }

    export interface CodeLensList {
        lenses: CodeLens[];
        dispose(): void;
    }

    export interface CodeLensProvider {
        onDidChange?: IEvent&lt;this&gt;;
        provideCodeLenses(model: editor.ITextModel, token: CancellationToken): ProviderResult&lt;CodeLensList&gt;;
        resolveCodeLens?(model: editor.ITextModel, codeLens: CodeLens, token: CancellationToken): ProviderResult&lt;CodeLens&gt;;
    }

    export enum InlayHintKind {
        Other &#x3D; 0,
        Type &#x3D; 1,
        Parameter &#x3D; 2
    }

    export interface InlayHint {
        text: string;
        position: IPosition;
        kind: InlayHintKind;
        whitespaceBefore?: boolean;
        whitespaceAfter?: boolean;
    }

    export interface InlayHintsProvider {
        onDidChangeInlayHints?: IEvent&lt;void&gt;;
        provideInlayHints(model: editor.ITextModel, range: Range, token: CancellationToken): ProviderResult&lt;InlayHint[]&gt;;
    }

    export interface SemanticTokensLegend {
        readonly tokenTypes: string[];
        readonly tokenModifiers: string[];
    }

    export interface SemanticTokens {
        readonly resultId?: string;
        readonly data: Uint32Array;
    }

    export interface SemanticTokensEdit {
        readonly start: number;
        readonly deleteCount: number;
        readonly data?: Uint32Array;
    }

    export interface SemanticTokensEdits {
        readonly resultId?: string;
        readonly edits: SemanticTokensEdit[];
    }

    export interface DocumentSemanticTokensProvider {
        onDidChange?: IEvent&lt;void&gt;;
        getLegend(): SemanticTokensLegend;
        provideDocumentSemanticTokens(model: editor.ITextModel, lastResultId: string | null, token: CancellationToken): ProviderResult&lt;SemanticTokens | SemanticTokensEdits&gt;;
        releaseDocumentSemanticTokens(resultId: string | undefined): void;
    }

    export interface DocumentRangeSemanticTokensProvider {
        getLegend(): SemanticTokensLegend;
        provideDocumentRangeSemanticTokens(model: editor.ITextModel, range: Range, token: CancellationToken): ProviderResult&lt;SemanticTokens&gt;;
    }

    export interface ILanguageExtensionPoint {
        id: string;
        extensions?: string[];
        filenames?: string[];
        filenamePatterns?: string[];
        firstLine?: string;
        aliases?: string[];
        mimetypes?: string[];
        configuration?: Uri;
    }
    /**
     * A Monarch language definition
     */
    export interface IMonarchLanguage {
        /**
         * map from string to ILanguageRule[]
         */
        tokenizer: {
            [name: string]: IMonarchLanguageRule[];
        };
        /**
         * is the language case insensitive?
         */
        ignoreCase?: boolean;
        /**
         * is the language unicode-aware? (i.e., /\u{1D306}/)
         */
        unicode?: boolean;
        /**
         * if no match in the tokenizer assign this token class (default &#x27;source&#x27;)
         */
        defaultToken?: string;
        /**
         * for example [[&#x27;{&#x27;,&#x27;}&#x27;,&#x27;delimiter.curly&#x27;]]
         */
        brackets?: IMonarchLanguageBracket[];
        /**
         * start symbol in the tokenizer (by default the first entry is used)
         */
        start?: string;
        /**
         * attach this to every token class (by default &#x27;.&#x27; + name)
         */
        tokenPostfix?: string;
        /**
         * include line feeds (in the form of a \n character) at the end of lines
         * Defaults to false
         */
        includeLF?: boolean;
        /**
         * Other keys that can be referred to by the tokenizer.
         */
        [key: string]: any;
    }

    /**
     * A rule is either a regular expression and an action
     * 		shorthands: [reg,act] &#x3D;&#x3D; { regex: reg, action: act}
     *		and       : [reg,act,nxt] &#x3D;&#x3D; { regex: reg, action: act{ next: nxt }}
     */
    export type IShortMonarchLanguageRule1 &#x3D; [string | RegExp, IMonarchLanguageAction];

    export type IShortMonarchLanguageRule2 &#x3D; [string | RegExp, IMonarchLanguageAction, string];

    export interface IExpandedMonarchLanguageRule {
        /**
         * match tokens
         */
        regex?: string | RegExp;
        /**
         * action to take on match
         */
        action?: IMonarchLanguageAction;
        /**
         * or an include rule. include all rules from the included state
         */
        include?: string;
    }

    export type IMonarchLanguageRule &#x3D; IShortMonarchLanguageRule1 | IShortMonarchLanguageRule2 | IExpandedMonarchLanguageRule;

    /**
     * An action is either an array of actions...
     * ... or a case statement with guards...
     * ... or a basic action with a token value.
     */
    export type IShortMonarchLanguageAction &#x3D; string;

    export interface IExpandedMonarchLanguageAction {
        /**
         * array of actions for each parenthesized match group
         */
        group?: IMonarchLanguageAction[];
        /**
         * map from string to ILanguageAction
         */
        cases?: Object;
        /**
         * token class (ie. css class) (or &quot;@brackets&quot; or &quot;@rematch&quot;)
         */
        token?: string;
        /**
         * the next state to push, or &quot;@push&quot;, &quot;@pop&quot;, &quot;@popall&quot;
         */
        next?: string;
        /**
         * switch to this state
         */
        switchTo?: string;
        /**
         * go back n characters in the stream
         */
        goBack?: number;
        /**
         * @open or @close
         */
        bracket?: string;
        /**
         * switch to embedded language (using the mimetype) or get out using &quot;@pop&quot;
         */
        nextEmbedded?: string;
        /**
         * log a message to the browser console window
         */
        log?: string;
    }

    export type IMonarchLanguageAction &#x3D; IShortMonarchLanguageAction | IExpandedMonarchLanguageAction | IShortMonarchLanguageAction[] | IExpandedMonarchLanguageAction[];

    /**
     * This interface can be shortened as an array, ie. [&#x27;{&#x27;,&#x27;}&#x27;,&#x27;delimiter.curly&#x27;]
     */
    export interface IMonarchLanguageBracket {
        /**
         * open bracket
         */
        open: string;
        /**
         * closing bracket
         */
        close: string;
        /**
         * token class
         */
        token: string;
    }

}

declare namespace monaco.worker {


    export interface IMirrorTextModel {
        readonly version: number;
    }

    export interface IMirrorModel extends IMirrorTextModel {
        readonly uri: Uri;
        readonly version: number;
        getValue(): string;
    }

    export interface IWorkerContext&lt;H &#x3D; undefined&gt; {
        /**
         * A proxy to the main thread host object.
         */
        host: H;
        /**
         * Get all available mirror models in this worker.
         */
        getMirrorModels(): IMirrorModel[];
    }

}

//dtsv&#x3D;3

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

declare namespace monaco.languages.typescript {
    export enum ModuleKind {
        None &#x3D; 0,
        CommonJS &#x3D; 1,
        AMD &#x3D; 2,
        UMD &#x3D; 3,
        System &#x3D; 4,
        ES2015 &#x3D; 5,
        ESNext &#x3D; 99
    }
    export enum JsxEmit {
        None &#x3D; 0,
        Preserve &#x3D; 1,
        React &#x3D; 2,
        ReactNative &#x3D; 3,
        ReactJSX &#x3D; 4,
        ReactJSXDev &#x3D; 5
    }
    export enum NewLineKind {
        CarriageReturnLineFeed &#x3D; 0,
        LineFeed &#x3D; 1
    }
    export enum ScriptTarget {
        ES3 &#x3D; 0,
        ES5 &#x3D; 1,
        ES2015 &#x3D; 2,
        ES2016 &#x3D; 3,
        ES2017 &#x3D; 4,
        ES2018 &#x3D; 5,
        ES2019 &#x3D; 6,
        ES2020 &#x3D; 7,
        ESNext &#x3D; 99,
        JSON &#x3D; 100,
        Latest &#x3D; 99
    }
    export enum ModuleResolutionKind {
        Classic &#x3D; 1,
        NodeJs &#x3D; 2
    }
    interface MapLike&lt;T&gt; {
        [index: string]: T;
    }
    type CompilerOptionsValue &#x3D; string | number | boolean | (string | number)[] | string[] | MapLike&lt;string[]&gt; | null | undefined;
    interface CompilerOptions {
        allowJs?: boolean;
        allowSyntheticDefaultImports?: boolean;
        allowUmdGlobalAccess?: boolean;
        allowUnreachableCode?: boolean;
        allowUnusedLabels?: boolean;
        alwaysStrict?: boolean;
        baseUrl?: string;
        charset?: string;
        checkJs?: boolean;
        declaration?: boolean;
        declarationMap?: boolean;
        emitDeclarationOnly?: boolean;
        declarationDir?: string;
        disableSizeLimit?: boolean;
        disableSourceOfProjectReferenceRedirect?: boolean;
        downlevelIteration?: boolean;
        emitBOM?: boolean;
        emitDecoratorMetadata?: boolean;
        experimentalDecorators?: boolean;
        forceConsistentCasingInFileNames?: boolean;
        importHelpers?: boolean;
        inlineSourceMap?: boolean;
        inlineSources?: boolean;
        isolatedModules?: boolean;
        jsx?: JsxEmit;
        keyofStringsOnly?: boolean;
        lib?: string[];
        locale?: string;
        mapRoot?: string;
        maxNodeModuleJsDepth?: number;
        module?: ModuleKind;
        moduleResolution?: ModuleResolutionKind;
        newLine?: NewLineKind;
        noEmit?: boolean;
        noEmitHelpers?: boolean;
        noEmitOnError?: boolean;
        noErrorTruncation?: boolean;
        noFallthroughCasesInSwitch?: boolean;
        noImplicitAny?: boolean;
        noImplicitReturns?: boolean;
        noImplicitThis?: boolean;
        noStrictGenericChecks?: boolean;
        noUnusedLocals?: boolean;
        noUnusedParameters?: boolean;
        noImplicitUseStrict?: boolean;
        noLib?: boolean;
        noResolve?: boolean;
        out?: string;
        outDir?: string;
        outFile?: string;
        paths?: MapLike&lt;string[]&gt;;
        preserveConstEnums?: boolean;
        preserveSymlinks?: boolean;
        project?: string;
        reactNamespace?: string;
        jsxFactory?: string;
        composite?: boolean;
        removeComments?: boolean;
        rootDir?: string;
        rootDirs?: string[];
        skipLibCheck?: boolean;
        skipDefaultLibCheck?: boolean;
        sourceMap?: boolean;
        sourceRoot?: string;
        strict?: boolean;
        strictFunctionTypes?: boolean;
        strictBindCallApply?: boolean;
        strictNullChecks?: boolean;
        strictPropertyInitialization?: boolean;
        stripInternal?: boolean;
        suppressExcessPropertyErrors?: boolean;
        suppressImplicitAnyIndexErrors?: boolean;
        target?: ScriptTarget;
        traceResolution?: boolean;
        resolveJsonModule?: boolean;
        types?: string[];
        /** Paths used to compute primary types search locations */
        typeRoots?: string[];
        esModuleInterop?: boolean;
        useDefineForClassFields?: boolean;
        [option: string]: CompilerOptionsValue | undefined;
    }
    export interface DiagnosticsOptions {
        noSemanticValidation?: boolean;
        noSyntaxValidation?: boolean;
        noSuggestionDiagnostics?: boolean;
        /**
         * Limit diagnostic computation to only visible files.
         * Defaults to false.
         */
        onlyVisible?: boolean;
        diagnosticCodesToIgnore?: number[];
    }
    export interface WorkerOptions {
        /** A full HTTP path to a JavaScript file which adds a function &#x60;customTSWorkerFactory&#x60; to the self inside a web-worker */
        customWorkerPath?: string;
    }
    interface InlayHintsOptions {
        readonly includeInlayParameterNameHints?: &#x27;none&#x27; | &#x27;literals&#x27; | &#x27;all&#x27;;
        readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
        readonly includeInlayFunctionParameterTypeHints?: boolean;
        readonly includeInlayVariableTypeHints?: boolean;
        readonly includeInlayPropertyDeclarationTypeHints?: boolean;
        readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
        readonly includeInlayEnumMemberValueHints?: boolean;
    }
    interface IExtraLib {
        content: string;
        version: number;
    }
    export interface IExtraLibs {
        [path: string]: IExtraLib;
    }
    /**
     * A linked list of formatted diagnostic messages to be used as part of a multiline message.
     * It is built from the bottom up, leaving the head to be the &quot;main&quot; diagnostic.
     */
    interface DiagnosticMessageChain {
        messageText: string;
        /** Diagnostic category: warning &#x3D; 0, error &#x3D; 1, suggestion &#x3D; 2, message &#x3D; 3 */
        category: 0 | 1 | 2 | 3;
        code: number;
        next?: DiagnosticMessageChain[];
    }
    export interface Diagnostic extends DiagnosticRelatedInformation {
        /** May store more in future. For now, this will simply be &#x60;true&#x60; to indicate when a diagnostic is an unused-identifier diagnostic. */
        reportsUnnecessary?: {};
        reportsDeprecated?: {};
        source?: string;
        relatedInformation?: DiagnosticRelatedInformation[];
    }
    export interface DiagnosticRelatedInformation {
        /** Diagnostic category: warning &#x3D; 0, error &#x3D; 1, suggestion &#x3D; 2, message &#x3D; 3 */
        category: 0 | 1 | 2 | 3;
        code: number;
        /** TypeScriptWorker removes all but the &#x60;fileName&#x60; property to avoid serializing circular JSON structures. */
        file: {
            fileName: string;
        } | undefined;
        start: number | undefined;
        length: number | undefined;
        messageText: string | DiagnosticMessageChain;
    }
    interface EmitOutput {
        outputFiles: OutputFile[];
        emitSkipped: boolean;
    }
    interface OutputFile {
        name: string;
        writeByteOrderMark: boolean;
        text: string;
    }
    export interface LanguageServiceDefaults {
        /**
         * Event fired when compiler options or diagnostics options are changed.
         */
        readonly onDidChange: IEvent&lt;void&gt;;
        /**
         * Event fired when extra libraries registered with the language service change.
         */
        readonly onDidExtraLibsChange: IEvent&lt;void&gt;;
        readonly workerOptions: WorkerOptions;
        readonly inlayHintsOptions: InlayHintsOptions;
        /**
         * Get the current extra libs registered with the language service.
         */
        getExtraLibs(): IExtraLibs;
        /**
         * Add an additional source file to the language service. Use this
         * for typescript (definition) files that won&#x27;t be loaded as editor
         * documents, like &#x60;jquery.d.ts&#x60;.
         *
         * @param content The file content
         * @param filePath An optional file path
         * @returns A disposable which will remove the file from the
         * language service upon disposal.
         */
        addExtraLib(content: string, filePath?: string): IDisposable;
        /**
         * Remove all existing extra libs and set the additional source
         * files to the language service. Use this for typescript definition
         * files that won&#x27;t be loaded as editor documents, like &#x60;jquery.d.ts&#x60;.
         * @param libs An array of entries to register.
         */
        setExtraLibs(libs: {
            content: string;
            filePath?: string;
        }[]): void;
        /**
         * Get current TypeScript compiler options for the language service.
         */
        getCompilerOptions(): CompilerOptions;
        /**
         * Set TypeScript compiler options.
         */
        setCompilerOptions(options: CompilerOptions): void;
        /**
         * Get the current diagnostics options for the language service.
         */
        getDiagnosticsOptions(): DiagnosticsOptions;
        /**
         * Configure whether syntactic and/or semantic validation should
         * be performed
         */
        setDiagnosticsOptions(options: DiagnosticsOptions): void;
        /**
         * Configure webworker options
         */
        setWorkerOptions(options: WorkerOptions): void;
        /**
         * No-op.
         */
        setMaximumWorkerIdleTime(value: number): void;
        /**
         * Configure if all existing models should be eagerly sync&#x27;d
         * to the worker on start or restart.
         */
        setEagerModelSync(value: boolean): void;
        /**
         * Get the current setting for whether all existing models should be eagerly sync&#x27;d
         * to the worker on start or restart.
         */
        getEagerModelSync(): boolean;
        /**
         * Configure inlay hints options.
         */
        setInlayHintsOptions(options: InlayHintsOptions): void;
    }
    export interface TypeScriptWorker {
        /**
         * Get diagnostic messages for any syntax issues in the given file.
         */
        getSyntacticDiagnostics(fileName: string): Promise&lt;Diagnostic[]&gt;;
        /**
         * Get diagnostic messages for any semantic issues in the given file.
         */
        getSemanticDiagnostics(fileName: string): Promise&lt;Diagnostic[]&gt;;
        /**
         * Get diagnostic messages for any suggestions related to the given file.
         */
        getSuggestionDiagnostics(fileName: string): Promise&lt;Diagnostic[]&gt;;
        /**
         * Get the content of a given file.
         */
        getScriptText(fileName: string): Promise&lt;string | undefined&gt;;
        /**
         * Get diagnostic messages related to the current compiler options.
         * @param fileName Not used
         */
        getCompilerOptionsDiagnostics(fileName: string): Promise&lt;Diagnostic[]&gt;;
        /**
         * Get code completions for the given file and position.
         * @returns &#x60;Promise&lt;typescript.CompletionInfo | undefined&gt;&#x60;
         */
        getCompletionsAtPosition(fileName: string, position: number): Promise&lt;any | undefined&gt;;
        /**
         * Get code completion details for the given file, position, and entry.
         * @returns &#x60;Promise&lt;typescript.CompletionEntryDetails | undefined&gt;&#x60;
         */
        getCompletionEntryDetails(fileName: string, position: number, entry: string): Promise&lt;any | undefined&gt;;
        /**
         * Get signature help items for the item at the given file and position.
         * @returns &#x60;Promise&lt;typescript.SignatureHelpItems | undefined&gt;&#x60;
         */
        getSignatureHelpItems(fileName: string, position: number, options: any): Promise&lt;any | undefined&gt;;
        /**
         * Get quick info for the item at the given position in the file.
         * @returns &#x60;Promise&lt;typescript.QuickInfo | undefined&gt;&#x60;
         */
        getQuickInfoAtPosition(fileName: string, position: number): Promise&lt;any | undefined&gt;;
        /**
         * Get other ranges which are related to the item at the given position in the file (often used for highlighting).
         * @returns &#x60;Promise&lt;ReadonlyArray&lt;typescript.ReferenceEntry&gt; | undefined&gt;&#x60;
         */
        getOccurrencesAtPosition(fileName: string, position: number): Promise&lt;ReadonlyArray&lt;any&gt; | undefined&gt;;
        /**
         * Get the definition of the item at the given position in the file.
         * @returns &#x60;Promise&lt;ReadonlyArray&lt;typescript.DefinitionInfo&gt; | undefined&gt;&#x60;
         */
        getDefinitionAtPosition(fileName: string, position: number): Promise&lt;ReadonlyArray&lt;any&gt; | undefined&gt;;
        /**
         * Get references to the item at the given position in the file.
         * @returns &#x60;Promise&lt;typescript.ReferenceEntry[] | undefined&gt;&#x60;
         */
        getReferencesAtPosition(fileName: string, position: number): Promise&lt;any[] | undefined&gt;;
        /**
         * Get outline entries for the item at the given position in the file.
         * @returns &#x60;Promise&lt;typescript.NavigationBarItem[]&gt;&#x60;
         */
        getNavigationBarItems(fileName: string): Promise&lt;any[]&gt;;
        /**
         * Get changes which should be applied to format the given file.
         * @param options &#x60;typescript.FormatCodeOptions&#x60;
         * @returns &#x60;Promise&lt;typescript.TextChange[]&gt;&#x60;
         */
        getFormattingEditsForDocument(fileName: string, options: any): Promise&lt;any[]&gt;;
        /**
         * Get changes which should be applied to format the given range in the file.
         * @param options &#x60;typescript.FormatCodeOptions&#x60;
         * @returns &#x60;Promise&lt;typescript.TextChange[]&gt;&#x60;
         */
        getFormattingEditsForRange(fileName: string, start: number, end: number, options: any): Promise&lt;any[]&gt;;
        /**
         * Get formatting changes which should be applied after the given keystroke.
         * @param options &#x60;typescript.FormatCodeOptions&#x60;
         * @returns &#x60;Promise&lt;typescript.TextChange[]&gt;&#x60;
         */
        getFormattingEditsAfterKeystroke(fileName: string, postion: number, ch: string, options: any): Promise&lt;any[]&gt;;
        /**
         * Get other occurrences which should be updated when renaming the item at the given file and position.
         * @returns &#x60;Promise&lt;readonly typescript.RenameLocation[] | undefined&gt;&#x60;
         */
        findRenameLocations(fileName: string, positon: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename: boolean): Promise&lt;readonly any[] | undefined&gt;;
        /**
         * Get edits which should be applied to rename the item at the given file and position (or a failure reason).
         * @param options &#x60;typescript.RenameInfoOptions&#x60;
         * @returns &#x60;Promise&lt;typescript.RenameInfo&gt;&#x60;
         */
        getRenameInfo(fileName: string, positon: number, options: any): Promise&lt;any&gt;;
        /**
         * Get transpiled output for the given file.
         * @returns &#x60;typescript.EmitOutput&#x60;
         */
        getEmitOutput(fileName: string): Promise&lt;EmitOutput&gt;;
        /**
         * Get possible code fixes at the given position in the file.
         * @param formatOptions &#x60;typescript.FormatCodeOptions&#x60;
         * @returns &#x60;Promise&lt;ReadonlyArray&lt;typescript.CodeFixAction&gt;&gt;&#x60;
         */
        getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: number[], formatOptions: any): Promise&lt;ReadonlyArray&lt;any&gt;&gt;;
        /**
         * Get inlay hints in the range of the file.
         * @param fileName
         * @returns &#x60;Promise&lt;typescript.InlayHint[]&gt;&#x60;
         */
        provideInlayHints(fileName: string, start: number, end: number): Promise&lt;ReadonlyArray&lt;any&gt;&gt;;
    }
    export const typescriptVersion: string;
    export const typescriptDefaults: LanguageServiceDefaults;
    export const javascriptDefaults: LanguageServiceDefaults;
    export const getTypeScriptWorker: () &#x3D;&gt; Promise&lt;(...uris: Uri[]) &#x3D;&gt; Promise&lt;TypeScriptWorker&gt;&gt;;
    export const getJavaScriptWorker: () &#x3D;&gt; Promise&lt;(...uris: Uri[]) &#x3D;&gt; Promise&lt;TypeScriptWorker&gt;&gt;;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

declare namespace monaco.languages.css {
    export interface Options {
        readonly validate?: boolean;
        readonly lint?: {
            readonly compatibleVendorPrefixes?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly vendorPrefix?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly duplicateProperties?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly emptyRules?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly importStatement?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly boxModel?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly universalSelector?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly zeroUnits?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly fontFaceProperties?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly hexColorLength?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly argumentsInColorFunction?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly unknownProperties?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly ieHack?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly unknownVendorSpecificProperties?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly propertyIgnoredDueToDisplay?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly important?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly float?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
            readonly idSelector?: &#x27;ignore&#x27; | &#x27;warning&#x27; | &#x27;error&#x27;;
        };
        /**
         * Configures the CSS data types known by the langauge service.
         */
        readonly data?: CSSDataConfiguration;
    }
    export interface ModeConfiguration {
        /**
         * Defines whether the built-in completionItemProvider is enabled.
         */
        readonly completionItems?: boolean;
        /**
         * Defines whether the built-in hoverProvider is enabled.
         */
        readonly hovers?: boolean;
        /**
         * Defines whether the built-in documentSymbolProvider is enabled.
         */
        readonly documentSymbols?: boolean;
        /**
         * Defines whether the built-in definitions provider is enabled.
         */
        readonly definitions?: boolean;
        /**
         * Defines whether the built-in references provider is enabled.
         */
        readonly references?: boolean;
        /**
         * Defines whether the built-in references provider is enabled.
         */
        readonly documentHighlights?: boolean;
        /**
         * Defines whether the built-in rename provider is enabled.
         */
        readonly rename?: boolean;
        /**
         * Defines whether the built-in color provider is enabled.
         */
        readonly colors?: boolean;
        /**
         * Defines whether the built-in foldingRange provider is enabled.
         */
        readonly foldingRanges?: boolean;
        /**
         * Defines whether the built-in diagnostic provider is enabled.
         */
        readonly diagnostics?: boolean;
        /**
         * Defines whether the built-in selection range provider is enabled.
         */
        readonly selectionRanges?: boolean;
    }
    export interface LanguageServiceDefaults {
        readonly languageId: string;
        readonly onDidChange: IEvent&lt;LanguageServiceDefaults&gt;;
        readonly modeConfiguration: ModeConfiguration;
        readonly options: Options;
        setOptions(options: Options): void;
        setModeConfiguration(modeConfiguration: ModeConfiguration): void;
        /** @deprecated Use options instead */
        readonly diagnosticsOptions: DiagnosticsOptions;
        /** @deprecated Use setOptions instead */
        setDiagnosticsOptions(options: DiagnosticsOptions): void;
    }
    /** @deprecated Use Options instead */
    export type DiagnosticsOptions &#x3D; Options;
    export const cssDefaults: LanguageServiceDefaults;
    export const scssDefaults: LanguageServiceDefaults;
    export const lessDefaults: LanguageServiceDefaults;
    export interface CSSDataConfiguration {
        /**
         * Defines whether the standard CSS properties, at-directives, pseudoClasses and pseudoElements are shown.
         */
        useDefaultDataProvider?: boolean;
        /**
         * Provides a set of custom data providers.
         */
        dataProviders?: {
            [providerId: string]: CSSDataV1;
        };
    }
    /**
     * Custom CSS properties, at-directives, pseudoClasses and pseudoElements
     * https://github.com/microsoft/vscode-css-languageservice/blob/main/docs/customData.md
     */
    export interface CSSDataV1 {
        version: 1 | 1.1;
        properties?: IPropertyData[];
        atDirectives?: IAtDirectiveData[];
        pseudoClasses?: IPseudoClassData[];
        pseudoElements?: IPseudoElementData[];
    }
    export type EntryStatus &#x3D; &#x27;standard&#x27; | &#x27;experimental&#x27; | &#x27;nonstandard&#x27; | &#x27;obsolete&#x27;;
    export interface IReference {
        name: string;
        url: string;
    }
    export interface IPropertyData {
        name: string;
        description?: string | MarkupContent;
        browsers?: string[];
        restrictions?: string[];
        status?: EntryStatus;
        syntax?: string;
        values?: IValueData[];
        references?: IReference[];
        relevance?: number;
    }
    export interface IAtDirectiveData {
        name: string;
        description?: string | MarkupContent;
        browsers?: string[];
        status?: EntryStatus;
        references?: IReference[];
    }
    export interface IPseudoClassData {
        name: string;
        description?: string | MarkupContent;
        browsers?: string[];
        status?: EntryStatus;
        references?: IReference[];
    }
    export interface IPseudoElementData {
        name: string;
        description?: string | MarkupContent;
        browsers?: string[];
        status?: EntryStatus;
        references?: IReference[];
    }
    export interface IValueData {
        name: string;
        description?: string | MarkupContent;
        browsers?: string[];
        status?: EntryStatus;
        references?: IReference[];
    }
    export interface MarkupContent {
        kind: MarkupKind;
        value: string;
    }
    export type MarkupKind &#x3D; &#x27;plaintext&#x27; | &#x27;markdown&#x27;;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

declare namespace monaco.languages.json {
    export interface DiagnosticsOptions {
        /**
         * If set, the validator will be enabled and perform syntax and schema based validation,
         * unless &#x60;DiagnosticsOptions.schemaValidation&#x60; is set to &#x60;ignore&#x60;.
         */
        readonly validate?: boolean;
        /**
         * If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
         * &#x60;DiagnosticsOptions.allowComments&#x60; will override this setting.
         */
        readonly allowComments?: boolean;
        /**
         * A list of known schemas and/or associations of schemas to file names.
         */
        readonly schemas?: {
            /**
             * The URI of the schema, which is also the identifier of the schema.
             */
            readonly uri: string;
            /**
             * A list of glob patterns that describe for which file URIs the JSON schema will be used.
             * &#x27;*&#x27; and &#x27;**&#x27; wildcards are supported. Exclusion patterns start with &#x27;!&#x27;.
             * For example &#x27;*.schema.json&#x27;, &#x27;package.json&#x27;, &#x27;!foo*.schema.json&#x27;, &#x27;foo/**\/BADRESP.json&#x27;.
             * A match succeeds when there is at least one pattern matching and last matching pattern does not start with &#x27;!&#x27;.
             */
            readonly fileMatch?: string[];
            /**
             * The schema for the given URI.
             */
            readonly schema?: any;
        }[];
        /**
         *  If set, the schema service would load schema content on-demand with &#x27;fetch&#x27; if available
         */
        readonly enableSchemaRequest?: boolean;
        /**
         * The severity of problems from schema validation. If set to &#x27;ignore&#x27;, schema validation will be skipped. If not set, &#x27;warning&#x27; is used.
         */
        readonly schemaValidation?: SeverityLevel;
        /**
         * The severity of problems that occurred when resolving and loading schemas. If set to &#x27;ignore&#x27;, schema resolving problems are not reported. If not set, &#x27;warning&#x27; is used.
         */
        readonly schemaRequest?: SeverityLevel;
        /**
         * The severity of reported trailing commas. If not set, trailing commas will be reported as errors.
         */
        readonly trailingCommas?: SeverityLevel;
        /**
         * The severity of reported comments. If not set, &#x27;DiagnosticsOptions.allowComments&#x27; defines whether comments are ignored or reported as errors.
         */
        readonly comments?: SeverityLevel;
    }
    export type SeverityLevel &#x3D; &#x27;error&#x27; | &#x27;warning&#x27; | &#x27;ignore&#x27;;
    export interface ModeConfiguration {
        /**
         * Defines whether the built-in documentFormattingEdit provider is enabled.
         */
        readonly documentFormattingEdits?: boolean;
        /**
         * Defines whether the built-in documentRangeFormattingEdit provider is enabled.
         */
        readonly documentRangeFormattingEdits?: boolean;
        /**
         * Defines whether the built-in completionItemProvider is enabled.
         */
        readonly completionItems?: boolean;
        /**
         * Defines whether the built-in hoverProvider is enabled.
         */
        readonly hovers?: boolean;
        /**
         * Defines whether the built-in documentSymbolProvider is enabled.
         */
        readonly documentSymbols?: boolean;
        /**
         * Defines whether the built-in tokens provider is enabled.
         */
        readonly tokens?: boolean;
        /**
         * Defines whether the built-in color provider is enabled.
         */
        readonly colors?: boolean;
        /**
         * Defines whether the built-in foldingRange provider is enabled.
         */
        readonly foldingRanges?: boolean;
        /**
         * Defines whether the built-in diagnostic provider is enabled.
         */
        readonly diagnostics?: boolean;
        /**
         * Defines whether the built-in selection range provider is enabled.
         */
        readonly selectionRanges?: boolean;
    }
    export interface LanguageServiceDefaults {
        readonly languageId: string;
        readonly onDidChange: IEvent&lt;LanguageServiceDefaults&gt;;
        readonly diagnosticsOptions: DiagnosticsOptions;
        readonly modeConfiguration: ModeConfiguration;
        setDiagnosticsOptions(options: DiagnosticsOptions): void;
        setModeConfiguration(modeConfiguration: ModeConfiguration): void;
    }
    export const jsonDefaults: LanguageServiceDefaults;
}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

declare namespace monaco.languages.html {
    export interface HTMLFormatConfiguration {
        readonly tabSize: number;
        readonly insertSpaces: boolean;
        readonly wrapLineLength: number;
        readonly unformatted: string;
        readonly contentUnformatted: string;
        readonly indentInnerHtml: boolean;
        readonly preserveNewLines: boolean;
        readonly maxPreserveNewLines: number | undefined;
        readonly indentHandlebars: boolean;
        readonly endWithNewline: boolean;
        readonly extraLiners: string;
        readonly wrapAttributes: &#x27;auto&#x27; | &#x27;force&#x27; | &#x27;force-aligned&#x27; | &#x27;force-expand-multiline&#x27;;
    }
    export interface CompletionConfiguration {
        readonly [providerId: string]: boolean;
    }
    export interface Options {
        /**
         * If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
         */
        readonly format?: HTMLFormatConfiguration;
        /**
         * A list of known schemas and/or associations of schemas to file names.
         */
        readonly suggest?: CompletionConfiguration;
        /**
         * Configures the HTML data types known by the HTML langauge service.
         */
        readonly data?: HTMLDataConfiguration;
    }
    export interface ModeConfiguration {
        /**
         * Defines whether the built-in completionItemProvider is enabled.
         */
        readonly completionItems?: boolean;
        /**
         * Defines whether the built-in hoverProvider is enabled.
         */
        readonly hovers?: boolean;
        /**
         * Defines whether the built-in documentSymbolProvider is enabled.
         */
        readonly documentSymbols?: boolean;
        /**
         * Defines whether the built-in definitions provider is enabled.
         */
        readonly links?: boolean;
        /**
         * Defines whether the built-in references provider is enabled.
         */
        readonly documentHighlights?: boolean;
        /**
         * Defines whether the built-in rename provider is enabled.
         */
        readonly rename?: boolean;
        /**
         * Defines whether the built-in color provider is enabled.
         */
        readonly colors?: boolean;
        /**
         * Defines whether the built-in foldingRange provider is enabled.
         */
        readonly foldingRanges?: boolean;
        /**
         * Defines whether the built-in diagnostic provider is enabled.
         */
        readonly diagnostics?: boolean;
        /**
         * Defines whether the built-in selection range provider is enabled.
         */
        readonly selectionRanges?: boolean;
        /**
         * Defines whether the built-in documentFormattingEdit provider is enabled.
         */
        readonly documentFormattingEdits?: boolean;
        /**
         * Defines whether the built-in documentRangeFormattingEdit provider is enabled.
         */
        readonly documentRangeFormattingEdits?: boolean;
    }
    export interface LanguageServiceDefaults {
        readonly languageId: string;
        readonly modeConfiguration: ModeConfiguration;
        readonly onDidChange: IEvent&lt;LanguageServiceDefaults&gt;;
        readonly options: Options;
        setOptions(options: Options): void;
        setModeConfiguration(modeConfiguration: ModeConfiguration): void;
    }
    export const htmlLanguageService: LanguageServiceRegistration;
    export const htmlDefaults: LanguageServiceDefaults;
    export const handlebarLanguageService: LanguageServiceRegistration;
    export const handlebarDefaults: LanguageServiceDefaults;
    export const razorLanguageService: LanguageServiceRegistration;
    export const razorDefaults: LanguageServiceDefaults;
    export interface LanguageServiceRegistration extends IDisposable {
        readonly defaults: LanguageServiceDefaults;
    }
    /**
     * Registers a new HTML language service for the languageId.
     * Note: &#x27;html&#x27;, &#x27;handlebar&#x27; and &#x27;razor&#x27; are registered by default.
     *
     * Use this method to register additional language ids with a HTML service.
     * The language server has to be registered before an editor model is opened.
     */
    export function registerHTMLLanguageService(languageId: string, options?: Options, modeConfiguration?: ModeConfiguration): LanguageServiceRegistration;
    export interface HTMLDataConfiguration {
        /**
         * Defines whether the standard HTML tags and attributes are shown
         */
        readonly useDefaultDataProvider?: boolean;
        /**
         * Provides a set of custom data providers.
         */
        readonly dataProviders?: {
            [providerId: string]: HTMLDataV1;
        };
    }
    /**
     * Custom HTML tags attributes and attribute values
     * https://github.com/microsoft/vscode-html-languageservice/blob/main/docs/customData.md
     */
    export interface HTMLDataV1 {
        readonly version: 1 | 1.1;
        readonly tags?: ITagData[];
        readonly globalAttributes?: IAttributeData[];
        readonly valueSets?: IValueSet[];
    }
    export interface IReference {
        readonly name: string;
        readonly url: string;
    }
    export interface ITagData {
        readonly name: string;
        readonly description?: string | MarkupContent;
        readonly attributes: IAttributeData[];
        readonly references?: IReference[];
    }
    export interface IAttributeData {
        readonly name: string;
        readonly description?: string | MarkupContent;
        readonly valueSet?: string;
        readonly values?: IValueData[];
        readonly references?: IReference[];
    }
    export interface IValueData {
        readonly name: string;
        readonly description?: string | MarkupContent;
        readonly references?: IReference[];
    }
    export interface IValueSet {
        readonly name: string;
        readonly values: IValueData[];
    }
    export interface MarkupContent {
        readonly kind: MarkupKind;
        readonly value: string;
    }
    export type MarkupKind &#x3D; &#x27;plaintext&#x27; | &#x27;markdown&#x27;;
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ILanguageExtensionPoint.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
